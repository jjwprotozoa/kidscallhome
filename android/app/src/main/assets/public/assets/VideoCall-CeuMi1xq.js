import{a7 as oe,aO as se,u as ce,r as V,j as le}from"./vendor-react-LQlp3yIU.js";import{u as de,V as fe}from"./useWebRTC-CDrKA3k0.js";import{s as m,v as W,a as t,u as ge,w as ue,r as he}from"./index-4JrybDns.js";import"./vendor-radix-BQCqNqg0.js";import"./vendor-other-DUaz7rji.js";import"./vendor-capacitor-DSxgEnoB.js";import"./vendor-supabase-Bq0a3XdW.js";const me=async(e,l,v,b,D,p,E)=>{let i=null;if(E){console.log("ðŸ“ž [PARENT CALL] Looking for specific call:",E);const{data:a,error:n}=await m.from("calls").select("*").eq("id",E).eq("parent_id",v).maybeSingle();n&&console.error("Error fetching specific call:",n),a&&(i=a,console.log("ðŸ“ž [PARENT CALL] Found specific call:",{id:i.id,caller_type:i.caller_type,status:i.status,hasOffer:!!i.offer}),i.caller_type==="child"?i.offer&&(i.status==="ringing"||i.status==="active"?(console.log(`ðŸ“ž [PARENT CALL] Answering incoming call from child (status: ${i.status}, hasOffer: true)`),b(i.id)):(console.log(`ðŸ“ž [PARENT CALL] Specific call is ended (status: ${i.status}), cannot answer.`),i=null)):i.caller_type==="parent"&&(i.status==="ringing"||i.status==="active")&&(console.log("ðŸ“ž [PARENT CALL] Using existing parent-initiated call"),i=null))}let f=null;if(!i||i.caller_type!=="child"){const{data:a}=await m.from("calls").select("*").eq("child_id",l).eq("parent_id",v).in("status",["ringing","active"]).eq("caller_type","parent").order("created_at",{ascending:!1}).limit(1).maybeSingle();f=a}if(f){if(console.log("ðŸ“ž [PARENT CALL] Using existing parent-initiated call:",f.id),b(f.id),f.answer&&e.remoteDescription===null){console.log("ðŸ“ž [PARENT CALL] Existing call has answer, setting remote description...");const a=f.answer;await e.setRemoteDescription(new RTCSessionDescription(a));for(const n of p.current)try{await e.addIceCandidate(new RTCIceCandidate(n))}catch(S){const A=S;!A.message?.includes("duplicate")&&!A.message?.includes("already")&&console.error("Error adding queued ICE candidate:",A.message)}p.current=[],D(!1)}else if(f.offer){if(f.offer){const a=f.offer,n=e.localDescription!==null,S=e.signalingState,A=e.getSenders().length>0;if(console.log("ðŸ“ž [PARENT CALL] Checking existing offer:",{hasLocalDescription:n,signalingState:S,hasTracks:A,offerType:a.type,offerSdpLength:a.sdp?.length}),A&&n)console.log("âœ… [PARENT CALL] Peer connection already initialized with tracks and local description. Skipping setLocalDescription - connection is already in progress.");else if(!n&&S==="stable"&&!A){console.log("ðŸ“ž [PARENT CALL] Setting local description from existing offer...");try{await e.setLocalDescription(new RTCSessionDescription(a)),console.log("âœ… [PARENT CALL] Successfully set local description from existing offer")}catch(c){const h=c;if(h.message?.includes("does not match")||h.message?.includes("SDP")||h.message?.includes("InvalidModificationError"))console.warn("âš ï¸ [PARENT CALL] Could not set local description - already set with different SDP. This may indicate the connection was already initialized. Continuing without error...");else throw console.error("âŒ [PARENT CALL] Unexpected error setting local description:",h),c}}else n?e.localDescription.sdp!==a.sdp?console.warn(`âš ï¸ [PARENT CALL] Local description already set but doesn't match existing offer. Current SDP length: ${e.localDescription.sdp?.length}, Offer SDP length: ${a.sdp?.length}. This may indicate a race condition. Skipping setLocalDescription and continuing.`):console.log("âœ… [PARENT CALL] Local description already matches existing offer"):console.warn(`âš ï¸ [PARENT CALL] Cannot set local description - signaling state is "${S}", hasTracks: ${A}. This may indicate the connection is already in progress. Skipping setLocalDescription.`)}}else{console.log("ðŸ“ž [PARENT CALL] Existing call has no offer, creating one...");const a=await e.createOffer();console.log("[KCH]","parent","created offer",!!a?.sdp),await e.setLocalDescription(a),console.log("[KCH]","parent","saving offer for call",f.id),await m.from("calls").update({offer:{type:a.type,sdp:a.sdp}}).eq("id",f.id)}return m.channel(`call:${f.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${f.id}`},async a=>{try{const n=a.new,S=a.old;if(W(n)){const c=e.iceConnectionState;console.error("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party (parent handler - existing call)",{callId:n.id,oldStatus:S?.status,newStatus:n.status,reason:"Status changed to 'ended' in database",timestamp:new Date().toISOString(),connectionState:e.connectionState,iceConnectionState:c,signalingState:e.signalingState}),e.signalingState!=="closed"&&e.close();return}if(n.answer&&e.remoteDescription===null)try{console.log("âœ… [PARENT HANDLER] Parent received answer from child (existing call), setting remote description...");const c=n.answer;await e.setRemoteDescription(new RTCSessionDescription(c));for(const h of p.current)try{await e.addIceCandidate(new RTCIceCandidate(h))}catch(N){const O=N;!O.message?.includes("duplicate")&&!O.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding queued ICE candidate:",O.message)}p.current=[],D(!1)}catch(c){console.error("âŒ [PARENT HANDLER] Error setting remote description:",c)}const A=n.child_ice_candidates;if(A&&Array.isArray(A))for(const c of A)try{if(!c.candidate)continue;if(e.remoteDescription){const h=new RTCIceCandidate(c);await e.addIceCandidate(h)}else p.current.push(c)}catch(h){const N=h;!N.message?.includes("duplicate")&&!N.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding ICE candidate:",N.message)}}catch(n){console.error("Error in parent call update handler:",n)}}).subscribe()}let u=i&&i.caller_type==="child"?i:null;if(!u){const{data:a}=await m.from("calls").select("*").eq("child_id",l).eq("parent_id",v).eq("status","ringing").eq("caller_type","child").order("created_at",{ascending:!1}).limit(1).maybeSingle();u=a}if(u){if(D(!1),b(u.id),!u.offer)return console.log("Incoming call has no offer yet, waiting for offer..."),m.channel(`call:${u.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${u.id}`},async y=>{const o=y.new;if(o.offer&&e.remoteDescription===null){console.log("Received offer, setting remote description...");const g=o.offer;await e.setRemoteDescription(new RTCSessionDescription(g)),await new Promise($=>{const _=()=>{e.signalingState==="have-remote-offer"||e.signalingState==="have-local-pranswer"?$():setTimeout(_,100)};_()});const C=await e.createAnswer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});console.log("[KCH]","parent","created answer",!!C?.sdp),await e.setLocalDescription(C),console.log("[KCH]","parent","saving answer for call",u.id),await m.from("calls").update({answer:{type:C.type,sdp:C.sdp},status:"active",ended_at:null}).eq("id",u.id),D(!1)}}).subscribe();const a=u.offer;console.log("âœ… [PARENT HANDLER] Setting remote description with child's offer..."),await e.setRemoteDescription(new RTCSessionDescription(a)),await new Promise((r,y)=>{const o=setTimeout(()=>{y(new Error("Timeout waiting for signaling state change"))},5e3),g=()=>{e.signalingState==="have-remote-offer"||e.signalingState==="have-local-pranswer"?(clearTimeout(o),r()):setTimeout(g,100)};g()});const n=e.getSenders().map(r=>r.track).filter(Boolean);if(console.log("ðŸ“¹ [PARENT HANDLER] Tracks in peer connection before answer:",{audioTracks:n.filter(r=>r?.kind==="audio").length,videoTracks:n.filter(r=>r?.kind==="video").length,totalTracks:n.length,senders:e.getSenders().length,trackDetails:n.map(r=>({kind:r.kind,id:r.id,enabled:r.enabled,muted:r.muted}))}),n.length===0)throw console.error("âŒ [PARENT HANDLER] NO TRACKS FOUND in peer connection! This will cause no video/audio. Make sure initializeConnection() was called and tracks were added."),new Error("Cannot create answer: no media tracks found. Please ensure camera/microphone permissions are granted.");const S=n.filter(r=>r?.kind==="audio"),A=n.filter(r=>r?.kind==="video");if(S.length===0&&A.length===0)throw console.error("âŒ [PARENT HANDLER] No audio or video tracks found!"),new Error("Cannot create answer: no media tracks available.");console.log("âœ… [PARENT HANDLER] Creating answer, current state:",e.signalingState);const c=await e.createAnswer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});console.log("[KCH]","parent","created answer",!!c?.sdp),console.log("âœ… [PARENT HANDLER] Answer created, setting local description..."),await e.setLocalDescription(c);const h=c.sdp?.includes("m=audio"),N=c.sdp?.includes("m=video");if(console.log("ðŸ“‹ [PARENT HANDLER] Answer SDP verification:",{type:c.type,sdpLength:c.sdp?.length,hasAudio:h,hasVideo:N,sdpPreview:c.sdp?.substring(0,200)}),!h&&!N)throw console.error("âŒ [PARENT HANDLER] CRITICAL: Answer SDP has no media tracks! This will cause no video/audio."),new Error("Answer SDP missing media tracks - ensure tracks are added before creating answer");console.log("âœ… [PARENT HANDLER] Updating call with answer...",{callId:u.id,answerType:c.type}),console.log("[KCH]","parent","saving answer for call",u.id);const{error:O}=await m.from("calls").update({answer:{type:c.type,sdp:c.sdp},status:"active",ended_at:null}).eq("id",u.id);if(O)throw console.error("âŒ [PARENT HANDLER] Error updating call with answer:",O),new Error(`Failed to send answer: ${O.message}`);console.log("âœ… [PARENT HANDLER] Answer sent successfully to child");const R=p.current.length;if(R>0){console.log(`âœ… [PARENT HANDLER] Processing ${R} queued ICE candidates after answer`);for(const r of p.current)try{await e.addIceCandidate(new RTCIceCandidate(r))}catch(y){const o=y;!o.message?.includes("duplicate")&&!o.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error processing queued ICE candidate:",o.message)}p.current=[]}return D(!1),console.log("âœ… [PARENT HANDLER] Call connected! Parent answered child's call."),(async()=>{try{const{data:r}=await m.from("calls").select("child_ice_candidates").eq("id",u.id).maybeSingle();if(r){const y=r.child_ice_candidates;if(y&&Array.isArray(y)&&y.length>0){console.log("ðŸ§Š [PARENT HANDLER] Processing existing ICE candidates from child (immediate):",{count:y.length,hasRemoteDescription:!!e.remoteDescription,iceConnectionState:e.iceConnectionState});for(const o of y)try{if(!o.candidate)continue;e.remoteDescription?await e.addIceCandidate(new RTCIceCandidate(o)):p.current.push(o)}catch(g){const C=g;!C.message?.includes("duplicate")&&!C.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding existing ICE candidate:",C.message)}console.log("âœ… [PARENT HANDLER] Finished processing existing ICE candidates from child")}}}catch(r){console.error("âŒ [PARENT HANDLER] Error fetching existing ICE candidates:",r)}})(),m.channel(`call:${u.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${u.id}`},async r=>{const y=r.new;if(y.status==="ended"){const g=e.iceConnectionState;console.error("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party (parent handler)",{callId:y.id,oldStatus:r.old?.status,newStatus:y.status,reason:"Status changed to 'ended' in database",timestamp:new Date().toISOString(),connectionState:e.connectionState,iceConnectionState:g,signalingState:e.signalingState}),console.log("ðŸ›‘ [CALL LIFECYCLE] Call ended - closing peer connection immediately",{iceState:g,reason:"Call status changed to 'ended' - closing regardless of ICE state"}),e.signalingState!=="closed"&&e.close();return}const o=y.child_ice_candidates;if(o&&Array.isArray(o)){const g=p.current.length,C=o.length;C>0&&(C<=5||C%5===0)&&console.log("ðŸ§Š [PARENT HANDLER] Processing ICE candidates (from child):",{count:C,queued:g,hasRemoteDescription:!!e.remoteDescription,iceConnectionState:e.iceConnectionState,source:"child_ice_candidates"});for(const $ of o)try{if(!$.candidate)continue;if(e.remoteDescription){const _=new RTCIceCandidate($);await e.addIceCandidate(_),C<=3&&console.log("âœ… [PARENT HANDLER] Added ICE candidate #"+C)}else p.current.push($),g<3&&console.log("â³ [PARENT HANDLER] Queued ICE candidate (waiting for remote description)")}catch(_){const F=_;!F.message?.includes("duplicate")&&!F.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding ICE candidate:",F.message)}}}).subscribe()}else{console.log("Parent initiating call to child:",l);const{data:a,error:n}=await m.from("calls").insert({child_id:l,parent_id:v,caller_type:"parent",status:"ringing"}).select().single();if(n)throw console.error("Call creation error:",n),new Error(`Failed to create call: ${n.message}`);if(!a)throw new Error("Failed to create call: No call data returned");console.log("Call created successfully:",a.id),b(a.id);const S=e.getSenders().map(o=>o.track).filter(Boolean);if(console.log("ðŸ“¹ [PARENT CALL] Tracks in peer connection before offer:",{audioTracks:S.filter(o=>o?.kind==="audio").length,videoTracks:S.filter(o=>o?.kind==="video").length,totalTracks:S.length,senders:e.getSenders().length,trackDetails:S.map(o=>({kind:o.kind,id:o.id,enabled:o.enabled,muted:o.muted}))}),S.length===0)throw console.error("âŒ [PARENT CALL] NO TRACKS FOUND in peer connection! This will cause no video/audio. Make sure initializeConnection() was called and tracks were added."),new Error("Cannot create offer: no media tracks found. Please ensure camera/microphone permissions are granted.");const A=S.filter(o=>o?.kind==="audio"),c=S.filter(o=>o?.kind==="video");if(A.length===0&&c.length===0)throw console.error("âŒ [PARENT CALL] No audio or video tracks found!"),new Error("Cannot create offer: no media tracks available.");console.log("Creating offer, current signaling state:",e.signalingState);const h=await e.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});console.log("[KCH]","parent","created offer",!!h?.sdp);const N=h.sdp?.includes("m=audio"),O=h.sdp?.includes("m=video");if(console.log("ðŸ“‹ [PARENT CALL] Offer SDP verification:",{hasAudio:N,hasVideo:O,sdpLength:h.sdp?.length,sdpPreview:h.sdp?.substring(0,200)}),!N&&!O)throw console.error("âŒ [PARENT CALL] CRITICAL: Offer SDP has no media tracks! This will cause no video/audio."),new Error("Offer SDP missing media tracks - ensure tracks are added before creating offer");console.log("Offer created, setting local description..."),await e.setLocalDescription(h);const R={type:h.type,sdp:h.sdp};console.log("Updating call with offer:",{callId:a.id,offerData:R}),console.log("[KCH]","parent","saving offer for call",a.id);const{data:I,error:r}=await m.from("calls").update({offer:R}).eq("id",a.id).select();if(console.log("Update response:",{data:I,error:r}),r)throw console.error("Error updating call with offer:",r),console.error("Error code:",r.code),console.error("Error message:",r.message),console.error("Error details:",JSON.stringify(r,null,2)),console.error("Call ID:",a.id),console.error("Offer data:",R),r.code==="PGRST204"||r.message?.includes("Could not find the 'offer' column")?new Error("Database schema cache is out of sync. Please refresh the page or contact support."):r.code==="42501"||r.code==="PGRST301"||r.message?.includes("permission denied")||r.message?.includes("new row violates row-level security")?new Error(`Permission denied: ${r.message}. Check RLS policies.`):new Error(`Failed to set offer: ${r.message}`);return console.log("âœ… [PARENT CALL] Offer sent successfully, waiting for child's answer..."),m.channel(`call:${a.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${a.id}`},async o=>{try{console.log("ðŸ“¡ [PARENT HANDLER] UPDATE event received:",{callId:a.id,hasNew:!!o.new,hasOld:!!o.old,timestamp:new Date().toISOString()});const g=o.new,C=o.old;console.log("ðŸ“¡ [PARENT HANDLER] Update details:",{hasAnswer:!!g.answer,hadAnswer:!!C?.answer,status:g.status,oldStatus:C?.status,hasRemoteDesc:!!e.remoteDescription}),C?.status!==g.status&&(g.status==="ended"||g.status==="active")&&(console.log("ðŸ“ž [PARENT HANDLER] Call status changed:",{callId:g.id,oldStatus:C?.status,newStatus:g.status}),g.status==="active"&&C?.status!=="active"&&(console.log("âœ… [PARENT HANDLER] Call status changed to active - stopping ringtone"),D(!1))),g.answer&&!C?.answer&&(console.log("âœ… [PARENT HANDLER] Answer received from child"),D(!1));const _=W(g),F=C?W(C):null;if(_&&C!==void 0&&F===!1){const k=e.iceConnectionState;console.info("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party (parent handler - parent initiated)",{callId:g.id,oldStatus:C?.status,newStatus:g.status,reason:"Status changed to 'ended' in database",timestamp:new Date().toISOString(),connectionState:e.connectionState,iceConnectionState:k,signalingState:e.signalingState}),console.log("ðŸ›‘ [CALL LIFECYCLE] Call ended - closing peer connection immediately",{iceState:k,reason:"Call status changed to 'ended' - closing regardless of ICE state"}),e.signalingState!=="closed"&&e.close();return}if(g.answer&&e.remoteDescription===null)try{D(!1),console.log("âœ… [PARENT HANDLER] Parent received answer from child, setting remote description...",{callId:g.id,hasAnswer:!!g.answer,answerType:g.answer?.type,currentRemoteDesc:!!e.remoteDescription,signalingState:e.signalingState});const k=g.answer;await e.setRemoteDescription(new RTCSessionDescription(k)),console.log("âœ… [PARENT HANDLER] Remote description set successfully from child's answer",{signalingState:e.signalingState,iceConnectionState:e.iceConnectionState});const U=p.current.length;if(U>0){console.log(`âœ… [PARENT HANDLER] Processing ${U} queued ICE candidates after answer`);for(const Y of p.current)try{await e.addIceCandidate(new RTCIceCandidate(Y))}catch(K){const z=K;!z.message?.includes("duplicate")&&!z.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding queued ICE candidate:",z.message)}p.current=[]}D(!1),console.log("âœ… [PARENT HANDLER] Call connected! Parent received answer from child.",{signalingState:e.signalingState,iceConnectionState:e.iceConnectionState,iceGatheringState:e.iceGatheringState,hasRemoteDescription:!!e.remoteDescription,hasLocalDescription:!!e.localDescription});const T=g.child_ice_candidates;T&&Array.isArray(T)&&T.length>0&&(console.log("ðŸ§Š [PARENT HANDLER] Processing existing ICE candidates from child (immediate after answer):",{count:T.length,hasRemoteDescription:!!e.remoteDescription,iceConnectionState:e.iceConnectionState}),(async()=>{for(const Y of T)try{if(!Y.candidate)continue;e.remoteDescription?(await e.addIceCandidate(new RTCIceCandidate(Y)),console.log("âœ… [PARENT HANDLER] Added existing ICE candidate from child")):p.current.push(Y)}catch(K){const z=K;!z.message?.includes("duplicate")&&!z.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding existing ICE candidate:",z.message)}})())}catch(k){console.error("âŒ [PARENT HANDLER] Error setting remote description:",k)}else g.answer&&e.remoteDescription!==null&&console.log("â„¹ï¸ [PARENT HANDLER] Answer received but remote description already set");const H=g.child_ice_candidates||g.ice_candidates;if(H&&Array.isArray(H)){const k=H.length;k>0&&k%10===0&&console.log("ðŸ§Š [PARENT HANDLER] Processing ICE candidates (from child):",{count:k,iceConnectionState:e.iceConnectionState});const U=new Set;for(const T of H)try{if(!T.candidate)continue;const Y=`${T.candidate}-${T.sdpMLineIndex}-${T.sdpMid||""}`;if(U.has(Y))continue;if(U.add(Y),e.remoteDescription){const K=new RTCIceCandidate(T);await e.addIceCandidate(K)}else p.current.push(T)}catch(Y){const K=Y;!K.message?.includes("duplicate")&&!K.message?.includes("already")&&console.error("âŒ [PARENT HANDLER] Error adding ICE candidate:",K.message)}U.size>0&&U.size%10===0&&console.log("âœ… [PARENT HANDLER] Processed",U.size,"ICE candidates from child",{iceConnectionState:e.iceConnectionState,connectionState:e.connectionState})}}catch(g){console.error("Error in parent call update handler:",g)}}).subscribe(o=>{console.log("ðŸ“¡ [PARENT CALL] Realtime subscription status:",o,{callId:a.id}),o==="SUBSCRIBED"?console.log("âœ… [PARENT CALL] Successfully subscribed to realtime updates for answer"):o==="CHANNEL_ERROR"&&console.error("âŒ [PARENT CALL] Realtime subscription error - answer may not be received!")})}},Ce=async(e,l,v,b,D,p,E)=>{if(E){const{data:a,error:n}=await m.from("calls").select("*").eq("id",E).eq("child_id",l.id).maybeSingle();if(a){if(t.log("ðŸ“ž [CHILD CALL] Found specific call:",{id:a.id,caller_type:a.caller_type,status:a.status,hasOffer:!!a.offer}),a.caller_type==="parent"&&a.offer){if(a.status==="ringing"||a.status==="active")return t.log("ðŸ“ž [CHILD CALL] Answering incoming call from parent (status:",a.status+", hasOffer: true)"),ee(e,a,b,D,p);t.log("ðŸ“ž [CHILD CALL] Specific call is ended (status:",a.status+"), cannot answer. Creating new call instead.")}if(a.caller_type==="child"&&(a.status==="ringing"||a.status==="active"))return ae(e,a,b,D,p);W(a)}}const{data:i,error:f}=await m.from("calls").select("*").eq("child_id",l.id).eq("caller_type","parent").eq("status","ringing").not("offer","is",null).order("created_at",{ascending:!1}).limit(1).maybeSingle();if(i){if(i.offer&&i.status==="ringing")return t.log("ðŸ“ž [CHILD CALL] Found incoming RINGING call from parent with offer:",{callId:i.id,status:i.status,hasOffer:!0}),ee(e,i,b,D,p);if(i.status!=="ringing")t.log("ðŸ“ž [CHILD CALL] Found call from parent but status is",i.status+", not ringing. Creating new call instead.");else{t.log("ðŸ“ž [CHILD CALL] Found incoming call from parent but offer not ready yet, waiting...",i.id),b(i.id);const a=m.channel(`call:${i.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${i.id}`},async n=>{const S=n.new;if(S.offer&&e.remoteDescription===null)return m.removeChannel(a),ee(e,S,b,D,p)}).subscribe();return a}}const{data:u}=await m.from("calls").select("*").eq("child_id",l.id).eq("parent_id",v.parent_id).in("status",["ringing","active"]).eq("caller_type","child").order("created_at",{ascending:!1}).limit(1).maybeSingle();return u?(t.log("ðŸ“ž [CHILD CALL] Found existing child-initiated call, continuing it:",u.id),ae(e,u,b,D,p)):we(e,l,v.parent_id,b,D,p)},ae=async(e,l,v,b,D)=>{t.log("Using existing call:",l.id),v(l.id);let p=!1;if(l.status==="ended"||l.status==="active"){t.log("Resetting existing call to ringing status (was:",l.status,")...");const{error:E}=await m.from("calls").update({status:"ringing",ended_at:null,offer:null,answer:null,parent_ice_candidates:null,child_ice_candidates:null}).eq("id",l.id);E||(l.status="ringing",l.offer=void 0,l.answer=void 0,p=!0)}if(p){const E=await e.createOffer();await e.setLocalDescription(E);const i={type:E.type,sdp:E.sdp},{error:f}=await m.from("calls").update({offer:i}).eq("id",l.id);if(f)throw new Error(`Failed to create offer: ${f.message}`)}else if(l.answer&&e.remoteDescription===null){if(e.localDescription===null){const i=await e.createOffer();await e.setLocalDescription(i);const f={type:i.type,sdp:i.sdp};await m.from("calls").update({offer:f}).eq("id",l.id)}const E=l.answer;await e.setRemoteDescription(new RTCSessionDescription(E));for(const i of D.current)await e.addIceCandidate(new RTCIceCandidate(i));D.current=[],b(!1)}else if(l.offer&&!p){if(e.localDescription===null){const E=await e.createOffer();await e.setLocalDescription(E);const i={type:E.type,sdp:E.sdp},{error:f}=await m.from("calls").update({offer:i}).eq("id",l.id);if(f)throw new Error(`Failed to create offer: ${f.message}`)}}else{const{data:E,error:i}=await m.from("calls").select("id, status, caller_type").eq("id",l.id).single();if(i||!E)throw new Error(`Call ${l.id} no longer exists or cannot be accessed`);if(W(E))throw new Error("Call has already ended");const f=await e.createOffer();await e.setLocalDescription(f);const u={type:f.type,sdp:f.sdp};t.log("Updating call with offer:",{callId:l.id,offerData:u});const{data:a,error:n}=await m.from("calls").update({offer:u}).eq("id",l.id).select();if(n)throw t.error("Error code:",n.code),t.error("Error message:",n.message),t.error("Error details:",JSON.stringify(n,null,2)),t.error("Call ID:",l.id),t.error("Offer data JSON:",JSON.stringify(u)),n.code==="PGRST204"||n.message?.includes("Could not find the 'offer' column")?new Error("Database schema cache is out of sync. Please refresh the page or contact support."):n.code==="42501"||n.code==="PGRST301"||n.message?.includes("permission denied")||n.message?.includes("new row violates row-level security")?new Error(`Permission denied: ${n.message}. Check RLS policies.`):n.code==="PGRST204"||n.code==="23514"?new Error(`Validation error: ${n.message}. Check data format.`):new Error(`Failed to send offer: ${n.message||JSON.stringify(n)}`)}return m.channel(`call:${l.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${l.id}`},async E=>{try{const i=E.new,f=E.old,u=W(i),a=f?W(f):null;if(u&&f!==void 0&&a===!1){const S=e.iceConnectionState;t.log("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party (child handler - existing call)",{callId:i.id,oldStatus:f?.status,newStatus:i.status,ended_at:i.ended_at,reason:"Status changed to terminal state in database",timestamp:new Date().toISOString(),connectionState:e.connectionState,iceConnectionState:S,signalingState:e.signalingState}),t.log("ðŸ›‘ [CALL LIFECYCLE] Call ended - closing peer connection immediately",{iceState:S,reason:"Call status changed to terminal - closing regardless of ICE state"}),e.signalingState!=="closed"&&e.close();return}if(i.status==="active"&&f?.status!=="active"&&t.log("Call status changed to active - parent answered the call!"),i.answer&&e.remoteDescription===null){t.log("Received answer from parent, setting remote description...");const S=i.answer;try{await e.setRemoteDescription(new RTCSessionDescription(S)),t.log("Remote description set successfully");for(const A of D.current)try{await e.addIceCandidate(new RTCIceCandidate(A))}catch{}D.current=[],b(!1),t.log("Call connected!")}catch(A){t.error("Error setting remote description:",A)}}const n=i.parent_ice_candidates;if(n&&Array.isArray(n)){const S=n.length;S>0&&S%10===0&&t.log("ðŸ§Š [CHILD HANDLER] Processing ICE candidates (from parent):",{count:S,iceConnectionState:e.iceConnectionState});for(const A of n)try{if(!A.candidate){t.warn("âš ï¸ [CHILD HANDLER] Skipping invalid candidate (no candidate field)");continue}if(e.remoteDescription){const c=new RTCIceCandidate(A);await e.addIceCandidate(c)}else D.current.push(A)}catch(c){const h=c;h.message?.includes("duplicate")||h.message?.includes("already")||t.error("âŒ [CHILD HANDLER] Error adding ICE candidate:",h.message)}}}catch{}}).subscribe()},ee=async(e,l,v,b,D)=>{if(t.log("âœ… [CHILD HANDLER] Answering incoming call from parent:",{callId:l.id,hasOffer:!!l.offer,offerType:l.offer?.type}),v(l.id),!l.offer)throw new Error("Cannot answer call: offer not found");const p=l.offer;await e.setRemoteDescription(new RTCSessionDescription(p)),await new Promise((c,h)=>{const N=setTimeout(()=>{h(new Error("Timeout waiting for signaling state change"))},5e3),O=()=>{e.signalingState==="have-remote-offer"||e.signalingState==="have-local-pranswer"?(clearTimeout(N),c()):setTimeout(O,100)};O()});const E=e.getSenders().map(c=>c.track).filter(Boolean);if(t.log("ðŸ“¹ [CHILD HANDLER] Tracks in peer connection before answer:",{audioTracks:E.filter(c=>c?.kind==="audio").length,videoTracks:E.filter(c=>c?.kind==="video").length,totalTracks:E.length,senders:e.getSenders().length,trackDetails:E.map(c=>({kind:c.kind,id:c.id,enabled:c.enabled,muted:c.muted}))}),E.length===0)throw new Error("Cannot create answer: no media tracks found. Please ensure camera/microphone permissions are granted.");const i=E.filter(c=>c?.kind==="audio"),f=E.filter(c=>c?.kind==="video");if(i.length===0&&f.length===0)throw new Error("Cannot create answer: no media tracks available.");t.log("âœ… [CHILD HANDLER] Creating answer, current state:",e.signalingState);const u=await e.createAnswer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});t.log("[KCH]","child","created answer",!!u?.sdp),await e.setLocalDescription(u);const a=u.sdp?.includes("m=audio"),n=u.sdp?.includes("m=video");if(t.log("ðŸ“‹ [CHILD HANDLER] Answer SDP verification:",{type:u.type,sdpLength:u.sdp?.length,hasAudio:a,hasVideo:n,sdpPreview:u.sdp?.substring(0,200)}),!a&&!n)throw new Error("Answer SDP missing media tracks - ensure tracks are added before creating answer");t.log("âœ… [CHILD HANDLER] Updating call with answer...",{callId:l.id,answerType:u.type}),t.log("[KCH]","child","saving answer for call",l.id);const{error:S}=await m.from("calls").update({answer:{type:u.type,sdp:u.sdp},status:"active",ended_at:null}).eq("id",l.id);if(S)throw new Error(`Failed to send answer: ${S.message}`);if(D.current.length>0){for(const c of D.current)try{await e.addIceCandidate(new RTCIceCandidate(c))}catch(h){const N=h;!N.message?.includes("duplicate")&&!N.message?.includes("already")&&t.error("âŒ [CHILD HANDLER] Error processing queued ICE candidate:",N.message)}D.current=[]}return b(!1),(async()=>{try{const{data:c}=await m.from("calls").select("parent_ice_candidates").eq("id",l.id).maybeSingle();if(c){const h=c.parent_ice_candidates;if(h&&Array.isArray(h)&&h.length>0){t.log("ðŸ§Š [CHILD HANDLER] Processing existing ICE candidates from parent (immediate):",{count:h.length,hasRemoteDescription:!!e.remoteDescription,iceConnectionState:e.iceConnectionState});for(const N of h)try{if(!N.candidate)continue;e.remoteDescription?(await e.addIceCandidate(new RTCIceCandidate(N)),t.log("âœ… [CHILD HANDLER] Added existing ICE candidate from parent")):D.current.push(N)}catch(O){const R=O;!R.message?.includes("duplicate")&&!R.message?.includes("already")&&t.error("âŒ [CHILD HANDLER] Error adding existing ICE candidate:",R.message)}}}}catch{}})(),m.channel(`call:${l.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${l.id}`},async c=>{const h=c.new,N=c.old,O=W(h),R=N?W(N):null;if(O&&N!==void 0&&R===!1){const r=e.iceConnectionState;t.log("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party (child handler - incoming call)",{callId:h.id,oldStatus:N?.status,newStatus:h.status,ended_at:h.ended_at,reason:"Status changed to terminal state in database",timestamp:new Date().toISOString(),connectionState:e.connectionState,iceConnectionState:r,signalingState:e.signalingState}),e.signalingState!=="closed"&&e.close();return}const I=h.parent_ice_candidates;if(I&&Array.isArray(I)){D.current.length;const r=I.length;r>0&&r%10===0&&t.log("ðŸ§Š [CHILD HANDLER] Processing ICE candidates (incoming call, from parent):",{count:r,iceConnectionState:e.iceConnectionState});const y=new Set;for(const o of I)try{if(!o.candidate)continue;const g=`${o.candidate}-${o.sdpMLineIndex}-${o.sdpMid||""}`;if(y.has(g))continue;if(y.add(g),e.remoteDescription){const C=new RTCIceCandidate(o);await e.addIceCandidate(C)}else D.current.push(o)}catch(g){const C=g;!C.message?.includes("duplicate")&&!C.message?.includes("already")&&t.error("âŒ [CHILD HANDLER] Error adding ICE candidate:",C.message)}r>0&&y.size>0&&y.size%10===0&&t.log("âœ… [CHILD HANDLER] Processed",y.size,"ICE candidates from parent",{iceConnectionState:e.iceConnectionState})}}).subscribe()},we=async(e,l,v,b,D,p)=>{t.log("ðŸ“ž [CHILD CALL] Creating call for child:",l.id,"parent:",v);const{data:E,error:i}=await m.from("children").select("id, parent_id").eq("id",l.id).eq("parent_id",v).single();if(i||!E)throw t.error("âŒ [CHILD CALL] Child verification failed:",{childId:l.id,parentId:v,error:i,childData:E}),new Error(`Child verification failed: ${i?.message||"Child not found or parent mismatch"}`);t.log("âœ… [CHILD CALL] Child verified, attempting insert:",{childId:l.id,parentId:v,childData:E});const{data:f,error:u}=await m.from("calls").insert({child_id:l.id,parent_id:v,caller_type:"child",status:"ringing"}).select().single();if(u)throw t.error("âŒ [CHILD CALL] Call creation error:",{error:u,code:u.code,message:u.message,details:u.details,hint:u.hint,insertData:{child_id:l.id,parent_id:v,caller_type:"child",status:"ringing"}}),new Error(`Failed to create call: ${u.message}`);if(!f)throw new Error("Failed to create call: No call data returned");if(t.log("âœ… [CHILD CALL] Call created successfully:",{callId:f.id,childId:f.child_id,parentId:f.parent_id,callerType:f.caller_type,status:f.status,createdAt:f.created_at}),b(f.id),e.signalingState==="closed")throw new Error("Peer connection is closed. Please try again.");if(e.connectionState==="closed"||e.connectionState==="failed")throw new Error(`Peer connection is in ${e.connectionState} state. Please try again.`);const a=e.getSenders().map(I=>I.track).filter(Boolean);if(t.log("ðŸ“¹ [CHILD CALL] Tracks in peer connection before offer:",{audioTracks:a.filter(I=>I?.kind==="audio").length,videoTracks:a.filter(I=>I?.kind==="video").length,totalTracks:a.length,senders:e.getSenders().length,trackDetails:a.map(I=>({kind:I.kind,id:I.id,enabled:I.enabled,muted:I.muted}))}),a.length===0)throw new Error("Cannot create offer: no media tracks found. Please ensure camera/microphone permissions are granted.");const n=a.filter(I=>I?.kind==="audio"),S=a.filter(I=>I?.kind==="video");if(n.length===0&&S.length===0)throw new Error("Cannot create offer: no media tracks available.");t.log("Creating offer, current signaling state:",e.signalingState);const A=await e.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});t.log("[KCH]","child","created offer",!!A?.sdp);const c=A.sdp?.includes("m=audio"),h=A.sdp?.includes("m=video");if(t.log("ðŸ“‹ [CHILD CALL] Offer SDP verification:",{hasAudio:c,hasVideo:h,sdpLength:A.sdp?.length,sdpPreview:A.sdp?.substring(0,200)}),!c&&!h)throw new Error("Offer SDP missing media tracks - ensure tracks are added before creating offer");await e.setLocalDescription(A);const N={type:A.type,sdp:A.sdp};t.log("Updating call with offer:",{callId:f.id,offerData:N}),t.log("[KCH]","child","saving offer for call",f.id);const{data:O,error:R}=await m.from("calls").update({offer:N}).eq("id",f.id).select();if(R)throw t.error("Error code:",R.code),t.error("Error message:",R.message),t.error("Error details:",JSON.stringify(R,null,2)),t.error("Call ID:",f.id),t.error("Offer data JSON:",JSON.stringify(N)),R.code==="PGRST204"||R.message?.includes("Could not find the 'offer' column")?new Error("Database schema cache is out of sync. Please refresh the page or contact support."):R.code==="42501"||R.code==="PGRST301"||R.message?.includes("permission denied")||R.message?.includes("new row violates row-level security")?new Error(`Permission denied: ${R.message}. Check RLS policies.`):R.code==="PGRST204"||R.code==="23514"?new Error(`Validation error: ${R.message}. Check data format.`):new Error(`Failed to send offer: ${R.message||JSON.stringify(R)}`);return m.channel(`call:${f.id}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${f.id}`},async I=>{const r=I.new,y=I.old,o=W(r),g=y?W(y):null;if(o&&y!==void 0&&g===!1){const $=e.iceConnectionState;t.log("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party (child handler - child initiated)",{callId:r.id,oldStatus:y?.status,newStatus:r.status,ended_at:r.ended_at,reason:"Status changed to terminal state in database",timestamp:new Date().toISOString(),connectionState:e.connectionState,iceConnectionState:$,signalingState:e.signalingState}),e.signalingState!=="closed"&&e.close();return}if(r.answer&&e.remoteDescription===null)try{t.log("âœ… [CHILD HANDLER] Received answer from parent, setting remote description...",{callId:r.id,hasAnswer:!!r.answer,answerType:r.answer?.type,currentRemoteDesc:!!e.remoteDescription});const $=r.answer;await e.setRemoteDescription(new RTCSessionDescription($)),t.log("âœ… [CHILD HANDLER] Remote description set successfully from parent's answer");for(const _ of p.current)try{await e.addIceCandidate(new RTCIceCandidate(_))}catch(F){const H=F;!H.message?.includes("duplicate")&&!H.message?.includes("already")&&t.error("âŒ [CHILD HANDLER] Error adding queued ICE candidate:",H.message)}p.current=[],D(!1),t.log("âœ… [CHILD HANDLER] Call connected! Child received answer from parent."),(async()=>{try{const{data:_}=await m.from("calls").select("parent_ice_candidates").eq("id",r.id).maybeSingle();if(_){const F=_.parent_ice_candidates;if(F&&Array.isArray(F)&&F.length>0){t.log("ðŸ§Š [CHILD HANDLER] Processing existing ICE candidates from parent (immediate after answer):",{count:F.length,hasRemoteDescription:!!e.remoteDescription,iceConnectionState:e.iceConnectionState});for(const H of F)try{if(!H.candidate)continue;e.remoteDescription?await e.addIceCandidate(new RTCIceCandidate(H)):p.current.push(H)}catch(k){const U=k;!U.message?.includes("duplicate")&&!U.message?.includes("already")&&t.error("âŒ [CHILD HANDLER] Error adding existing ICE candidate:",U.message)}t.log("âœ… [CHILD HANDLER] Finished processing existing ICE candidates from parent")}}}catch(_){t.error("âŒ [CHILD HANDLER] Error fetching existing ICE candidates:",_)}})()}catch{}const C=r.parent_ice_candidates;if(C&&Array.isArray(C)){p.current.length;const $=C.length;$>0&&$%10===0&&t.log("ðŸ§Š [CHILD HANDLER] Processing ICE candidates (child initiated, from parent):",{count:$,iceConnectionState:e.iceConnectionState});for(const _ of C)try{if(!_.candidate)continue;if(e.remoteDescription){const F=new RTCIceCandidate(_);await e.addIceCandidate(F)}else p.current.push(_)}catch(F){const H=F;!H.message?.includes("duplicate")&&!H.message?.includes("already")&&t.error("âŒ [CHILD HANDLER] Error adding ICE candidate:",H.message)}}}).subscribe()},pe=()=>{const{childId:e}=oe(),[l]=se(),v=ce(),{toast:b}=ge(),{playRingtone:D,stopRingtone:p,playCallAnswered:E}=ue({enabled:!0,volume:.7}),i=V.useRef(!1),f=window.location.pathname.includes("/child/"),u=window.location.pathname.includes("/parent/"),[a]=V.useState(()=>{if(f)return!0;if(u)return!1;const P=localStorage.getItem("childSession");return P&&window.location.pathname.match(/^\/call\/([^/?]+)/)?!0:!(document.cookie.includes("sb-")||localStorage.getItem("sb-"))&&!!P}),[n,S]=V.useState(null),[A,c]=V.useState(!1),[h,N]=V.useState(!1),O=V.useRef(null),R=V.useRef(null),I=V.useRef(null),r=V.useRef(null);t.debug("ðŸ” [ROLE DETECTION] useVideoCall role:",{isChild:a,route:window.location.pathname,isChildRoute:f,isParentRoute:u,timestamp:new Date().toISOString()});const{localStream:y,remoteStream:o,isConnecting:g,setIsConnecting:C,initializeConnection:$,cleanup:_,iceCandidatesQueue:F,peerConnectionRef:H,playRemoteVideo:k,isConnected:U}=de(n,O,R,a),T=V.useRef(!1);V.useEffect(()=>{T.current=!1},[n]),V.useEffect(()=>(g&&!o&&n?D():(o||!g)&&(p(),o&&!T.current&&E()),()=>{p()}),[g,o,n,D,p,E]),V.useEffect(()=>{if(o&&R.current&&!T.current){const d=H.current?.iceConnectionState,s=R.current,L=U&&!!o;if(t.debug("ðŸŽ¬ [VIDEO PLAY] Attempting to play remote video:",{hasRemoteStream:!!o,hasVideoElement:!!s,iceState:d,isConnecting:g,callIsConnected:L,videoReadyState:s.readyState,videoPaused:s.paused,videoSrcObject:!!s.srcObject}),L&&(d==="connected"||d==="completed"))if(s.readyState>=2)T.current=!0,t.debug("ðŸŽ¬ [VIDEO PLAY] Stream available, call connected, ICE connected, video ready (readyState:",s.readyState,")"),k();else{t.debug("â³ [VIDEO PLAY] Waiting for video readyState >= 2 (current:",s.readyState,")");const w=()=>{s.readyState>=2&&!T.current&&(T.current=!0,t.log("âœ… [VIDEO PLAY] Video ready (readyState:",s.readyState,"), attempting play"),k())};s.addEventListener("loadeddata",w,{once:!0}),s.addEventListener("canplay",w,{once:!0}),s.addEventListener("canplaythrough",w,{once:!0})}else if(L&&(d==="new"||d==="checking"))if(s.readyState>=2)T.current=!0,k();else{const w=()=>{s.readyState>=2&&!T.current&&(T.current=!0,k())};s.addEventListener("loadeddata",w,{once:!0}),s.addEventListener("canplay",w,{once:!0}),s.addEventListener("canplaythrough",w,{once:!0});const q=setInterval(()=>{const x=H.current?.iceConnectionState;(x==="connected"||x==="completed")&&(clearInterval(q),!T.current&&s.readyState>=2&&(T.current=!0,k()))},500);return setTimeout(()=>{clearInterval(q),T.current||(T.current=!0,k())},5e3),()=>clearInterval(q)}else if(!L&&(d==="new"||d==="checking")){const w=setInterval(()=>{const M=H.current?.iceConnectionState;if(!g&&(M==="connected"||M==="completed")){if(clearInterval(w),s.readyState>=2&&!T.current)T.current=!0,t.log("âœ… [VIDEO PLAY] Call connected, ICE connected, video ready (readyState:",s.readyState,"), attempting play"),k();else if(!T.current){const J=()=>{s.readyState>=2&&!T.current&&(T.current=!0,t.log("âœ… [VIDEO PLAY] Video ready after call and ICE connected (readyState:",s.readyState,")"),k())};s.addEventListener("loadeddata",J,{once:!0}),s.addEventListener("canplay",J,{once:!0}),s.addEventListener("canplaythrough",J,{once:!0})}}else(M==="failed"||M==="closed")&&clearInterval(w)},500);return setTimeout(()=>{clearInterval(w),!T.current&&s.readyState>=2&&(T.current=!0,k())},15e3),()=>clearInterval(w)}}},[o,k,g]),V.useEffect(()=>i.current?void 0:((async()=>{const{data:{session:d}}=await m.auth.getSession(),s=localStorage.getItem("childSession"),L=window.location.pathname.match(/^\/call\/([^/?]+)/);return s&&L?!0:!d&&!!s})().then(d=>{i.current=!0,Y(d).catch(s=>{{i.current=!1;const L=s instanceof Error?s.message:"Unknown error occurred";b({title:"Connection Error",description:L,variant:"destructive"})}})}).catch(d=>{}),()=>{}),[e]);const Y=async P=>{t.log("ðŸš€ [INITIALIZE CALL] ===== INITIALIZE CALL ENTRY =====",{isChildUser:P,childId:e,timestamp:new Date().toISOString()});try{t.log("ðŸš€ [INITIALIZE CALL] Initializing WebRTC connection..."),await $();const d=H.current;if(!d)throw new Error("Failed to create peer connection");t.log("ðŸš€ [INITIALIZE CALL] WebRTC connection initialized:",{signalingState:d.signalingState,senders:d.getSenders().length,tracks:d.getSenders().map(L=>L.track).filter(Boolean).length});let s;P?(t.log("ðŸš€ [INITIALIZE CALL] Setting up child call flow..."),s=await z(d)):(t.log("ðŸš€ [INITIALIZE CALL] Setting up parent call flow..."),s=await K(d)),t.log("ðŸš€ [INITIALIZE CALL] Call flow setup complete:",{hasChannel:!!s,isChildUser:P}),s&&(I.current=s)}catch(d){const s=d instanceof Error?d.message:"Unknown error occurred";throw b({title:"Connection Error",description:s,variant:"destructive"}),C(!1),d}},K=async P=>{t.log("ðŸš€ [PARENT CALL FLOW] ===== PARENT CALL FLOW ENTRY =====",{childId:e,timestamp:new Date().toISOString(),signalingState:P.signalingState,senders:P.getSenders().length,tracks:P.getSenders().map(d=>d.track).filter(Boolean).length});try{const{data:{user:d},error:s}=await m.auth.getUser();if(t.log("ðŸš€ [PARENT CALL FLOW] Auth check complete:",{hasUser:!!d,userId:d?.id,hasAuthError:!!s}),s)return t.error("Auth error in parent call flow:",s),b({title:"Authentication Error",description:"Please log in again to make calls",variant:"destructive"}),null;if(!d||!e)return t.error("Missing user or childId in parent call flow"),b({title:"Error",description:"Unable to start call. Please try again.",variant:"destructive"}),null;t.log("ðŸš€ [PARENT CALL FLOW] Calling handleParentCall...",{childId:e,userId:d.id,timestamp:new Date().toISOString()});const L=l.get("callId"),w=await me(P,e,d.id,q=>{t.log("ðŸš€ [PARENT CALL FLOW] CallId set:",q),S(q);const M=te(q);M&&(r.current=M)},C,F,L);return t.log("ðŸš€ [PARENT CALL FLOW] handleParentCall returned:",{hasChannel:!!w,timestamp:new Date().toISOString()}),w}catch(d){const s=d instanceof Error?d.message:"Unknown error occurred",L=s.includes("Database schema cache");throw b({title:L?"Database Schema Error":"Error",description:L?"The database schema cache needs to be refreshed. Please contact support or try refreshing the page.":s,variant:"destructive"}),C(!1),d}},z=async P=>{try{const d=l.get("callId"),s=!!d,L=localStorage.getItem("childSession");if(!L)if(s&&e)t.warn("âš ï¸ [CHILD CALL FLOW] No child session but answering call - attempting to continue with childId from URL");else{t.error("âŒ [CHILD CALL FLOW] No child session and not answering call - redirecting to login"),v("/child/login");return}const w=JSON.parse(L||"{}");if(!w.id&&s&&e&&(t.warn("âš ï¸ [CHILD CALL FLOW] Invalid child session but answering call - using childId from URL"),w.id=e),!w.id)if(t.error("âŒ [CHILD CALL FLOW] No valid child ID found"),s)t.warn("âš ï¸ [CHILD CALL FLOW] Continuing call without valid child ID");else{v("/child/login");return}const{data:q,error:M}=await m.from("children").select("parent_id").eq("id",w.id).single();if(M||!q)if(t.error("Child not found in database:",M),!n&&!s){localStorage.removeItem("childSession"),b({title:"Session expired",description:"Please log in again with your code",variant:"destructive"}),v("/child/login");return}else t.warn("âš ï¸ [CHILD CALL FLOW] Child verification failed but continuing call",{isAnsweringCall:s,hasCallId:!!n,reason:"Call is active or answering - don't navigate away"});let x=q?.parent_id;if(!x&&w.parent_id&&(x=w.parent_id,t.warn("âš ï¸ [CHILD CALL FLOW] Using parent_id from child session cache")),!x)if(t.error("âŒ [CHILD CALL FLOW] Unable to determine parent ID",{hasChildData:!!q,hasChildSession:!!w,childId:w.id}),d)t.warn("âš ï¸ [CHILD CALL FLOW] Continuing call without parent_id - call handler may have it");else throw new Error("Unable to determine parent ID for call. Please log in again.");if(!x&&d){t.log("âš ï¸ [CHILD CALL FLOW] No parentId but answering call - fetching from call record");try{const{data:G}=await m.from("calls").select("parent_id").eq("id",d).maybeSingle();G?.parent_id&&(x=G.parent_id,t.log("âœ… [CHILD CALL FLOW] Got parentId from call record:",x))}catch(G){t.warn("âš ï¸ [CHILD CALL FLOW] Could not fetch parentId from call record:",G)}}return await Ce(P,w,{parent_id:x||"unknown"},G=>{S(G);const B=te(G);B&&(r.current=B)},C,F,d)}catch(d){const s=d instanceof Error?d.message:"Unknown error occurred",L=s.includes("Database schema cache"),w=l.get("callId"),q=!!w;throw t.error("âŒ [CHILD CALL FLOW] Error in handleChildCallFlow:",{errorMessage:s,isAnsweringCall:q,urlCallId:w,hasChildSession:!!localStorage.getItem("childSession")}),b({title:L?"Database Schema Error":"Connection Error",description:L?"The database schema cache needs to be refreshed. Please contact support or try refreshing the page.":q?"Failed to connect to call. Please try again.":s,variant:"destructive"}),C(!1),q||v("/child/dashboard"),d}},re=()=>{if(y){const P=!A;y.getAudioTracks().forEach(d=>{d.enabled=!P}),c(P)}},ie=()=>{if(y){const P=!h;y.getVideoTracks().forEach(d=>{d.enabled=!P}),N(P)}},te=P=>m.channel(`call-termination:${P}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"calls",filter:`id=eq.${P}`},async s=>{try{const L=s.new,w=s.old;w?.status!==void 0&&w.status!==L.status&&t.log("ðŸ“ž [CALL LIFECYCLE] Call status update received:",{callId:L.id,oldStatus:w?.status,newStatus:L.status,timestamp:new Date().toISOString()});const M=W(L),x=w?W(w):null;if(t.log("ðŸ” [TERMINATION LISTENER] Checking termination conditions:",{isTerminal:M,hasOldCall:w!==void 0,wasTerminal:x,callIdMatch:L.id===P,oldStatus:w?.status,newStatus:L.status,oldEndedAt:w?.ended_at,newEndedAt:L.ended_at}),M&&w!==void 0&&x===!1&&L.id===P){const J=H.current,j=J?.iceConnectionState;t.log("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party - cleaning up",{callId:P,oldStatus:w?.status,newStatus:L.status,ended_at:L.ended_at,ended_by:L.ended_by,reason:"Call reached terminal state (ended or ended_at set) in database",timestamp:new Date().toISOString(),connectionState:J?.connectionState,iceConnectionState:j,hasRemoteStream:!!o,remoteVideoReadyState:R.current?.readyState});const G=j!=="new"&&j!=="checking";t.log("ðŸ›‘ [CALL LIFECYCLE] Call ended by remote party - cleaning up immediately",{iceState:j,reason:"Call reached terminal state - cleaning up regardless of ICE state"}),b({title:"Call Ended",description:"The other person ended the call",variant:"default"}),_(),I.current&&(m.removeChannel(I.current),I.current=null),r.current&&(m.removeChannel(r.current),r.current=null);const{data:{session:B}}=await m.auth.getSession(),Q=localStorage.getItem("childSession"),ne=window.location.pathname.match(/^\/call\/([^/?]+)/);let X=!1;Q&&ne?X=!0:X=!B&&!!Q,t.log("ðŸ” [USER TYPE DETECTION] Termination listener - determining user type:",{hasAuthSession:!!B,hasChildSession:!!Q,isChildUser:X,route:window.location.pathname,isCallPage:!!ne,userId:B?.user?.id||null,timestamp:new Date().toISOString()}),v(X?"/child/dashboard":B?"/parent/dashboard":"/")}}catch{}}).subscribe(),Z=V.useRef(null);return V.useEffect(()=>{U&&o&&n&&!Z.current&&(Z.current=Date.now(),t.log("ðŸ“ž [CALL LIFECYCLE] Call started (ICE connected)",{callId:n,timestamp:new Date().toISOString(),iceState:H.current?.iceConnectionState,connectionState:H.current?.connectionState}))},[U,o,n,H]),V.useEffect(()=>{!g&&n&&!Z.current&&!U&&t.log("ðŸ“ž [CALL LIFECYCLE] Call signaling complete (waiting for ICE)",{callId:n,timestamp:new Date().toISOString()})},[g,n]),{localVideoRef:O,remoteVideoRef:R,localStream:y,remoteStream:o,isConnecting:g,isMuted:A,isVideoOff:h,isChild:a,toggleMute:re,toggleVideo:ie,endCall:async()=>{const P=Z.current?Date.now()-Z.current:null;t.log("ðŸ›‘ [USER ACTION] User ended call",{callId:n,callDurationMs:P,callDurationSeconds:P?Math.round(P/1e3):null,timestamp:new Date().toISOString(),connectionState:H.current?.connectionState,iceConnectionState:H.current?.iceConnectionState,hasRemoteStream:!!o,remoteVideoReadyState:R.current?.readyState});const{data:{session:d}}=await m.auth.getSession(),s=localStorage.getItem("childSession"),L=!d&&!!s,w=L?"child":"parent";if(t.log("ðŸ” [USER TYPE DETECTION] End call - determining user type:",{hasAuthSession:!!d,hasChildSession:!!s,isChildUser:L,by:w,userId:d?.user?.id||null,timestamp:new Date().toISOString()}),n)try{await he({callId:n,by:w,reason:"hangup"})}catch{}Z.current=null,p(),_(!0),I.current&&(m.removeChannel(I.current),I.current=null),r.current&&(m.removeChannel(r.current),r.current=null),v(L?"/child/dashboard":"/parent/dashboard")}}},Te=()=>{const{localVideoRef:e,remoteVideoRef:l,remoteStream:v,isConnecting:b,isMuted:D,isVideoOff:p,toggleMute:E,toggleVideo:i,endCall:f,callStartTime:u}=pe();return le.jsx(fe,{localVideoRef:e,remoteVideoRef:l,remoteStream:v,isConnecting:b,isMuted:D,isVideoOff:p,onToggleMute:E,onToggleVideo:i,onEndCall:f,callStartTime:u})};export{Te as default};

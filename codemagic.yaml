# codemagic.yaml
# Codemagic CI/CD configuration for KidsCallHome native apps (Android & iOS)
# Capacitor-based PWA wrapped in native containers

workflows:
  android-build:
    name: Android Build
    max_build_duration: 120
    instance_type: mac_mini_m1
    environment:
      groups:
        - android_keystore
        - google_play
      node: 20
      java: 17
      vars:
        PACKAGE_NAME: "com.kidscallhome.app"
        APP_NAME: "Kids Call Home"
    scripts:
      - name: Install dependencies
        script: |
          npm ci

      - name: Build web app
        script: |
          npm run build

      - name: Sync Capacitor
        script: |
          npx cap sync android

      - name: Set up Android keystore
        script: |
          if [ ! -z "$CM_KEYSTORE_PATH" ]; then
            echo "âœ… Using keystore from CM_KEYSTORE_PATH"
          else
            echo "âš ï¸ No keystore configured, using debug signing"
          fi

      - name: Verify Java version and configure Gradle
        script: |
          echo "=== Java Environment Setup ==="
          echo "Java version:"
          java -version
          echo ""
          echo "JAVA_HOME before: $JAVA_HOME"

          # Ensure JAVA_HOME is set and points to Java 17
          # Codemagic sets java: 17, but JAVA_HOME might not be set
          if [ -z "$JAVA_HOME" ]; then
            # Try to find Java 17 using macOS java_home utility
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || echo "")
            if [ -z "$JAVA_HOME" ]; then
              # Fallback: find any Java 17+ installation
              export JAVA_HOME=$(/usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
            fi
            echo "Set JAVA_HOME to: $JAVA_HOME"
          fi

          # Verify JAVA_HOME points to a valid Java 17 installation
          if [ ! -z "$JAVA_HOME" ] && [ -f "$JAVA_HOME/bin/java" ]; then
            echo "JAVA_HOME after: $JAVA_HOME"
            echo "Java version from JAVA_HOME:"
            "$JAVA_HOME/bin/java" -version
            JAVA_VERSION_OUTPUT=$("$JAVA_HOME/bin/java" -version 2>&1)
            if echo "$JAVA_VERSION_OUTPUT" | grep -qE 'version "1\.[0-8]\.'; then
              echo "âŒ ERROR: JAVA_HOME points to Java 8 or earlier!"
              echo "Java version output: $JAVA_VERSION_OUTPUT"
              exit 1
            fi
            echo "âœ… Java version is 11+"
          else
            echo "âŒ ERROR: JAVA_HOME is not set or invalid!"
            echo "Please ensure java: 17 is set in Codemagic environment"
            exit 1
          fi

          # Export JAVA_HOME for this script step
          export JAVA_HOME

          # Configure Gradle to use Java 17
          cd android
          chmod +x ./gradlew

          # Stop any existing Gradle daemons (they might be using Java 8)
          echo ""
          echo "=== Stopping Gradle daemons ==="
          ./gradlew --stop || true
          echo "âœ… Gradle daemons stopped"

          # Set org.gradle.java.home in gradle.properties to ensure Gradle uses Java 17
          # This is critical for buildscript classpath resolution
          echo ""
          echo "=== Configuring Gradle to use Java 17 ==="
          if [ -f gradle.properties ]; then
            # Remove any existing org.gradle.java.home line (macOS compatible sed)
            sed -i '' '/^org\.gradle\.java\.home=/d' gradle.properties 2>/dev/null || \
            sed -i.bak '/^org\.gradle\.java\.home=/d' gradle.properties 2>/dev/null || \
            grep -v '^org\.gradle\.java\.home=' gradle.properties > gradle.properties.tmp && mv gradle.properties.tmp gradle.properties
            # Add the correct Java home
            echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            echo "âœ… Updated gradle.properties with org.gradle.java.home=$JAVA_HOME"
            echo "Verification - org.gradle.java.home setting:"
            grep "org.gradle.java.home" gradle.properties || echo "âš ï¸ Warning: org.gradle.java.home not found in gradle.properties"
          else
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
            echo "âœ… Created gradle.properties with org.gradle.java.home=$JAVA_HOME"
          fi

          # Verify Gradle wrapper will use correct Java
          echo ""
          echo "=== Verifying Gradle wrapper configuration ==="
          echo "Gradle wrapper will use: $JAVA_HOME/bin/java"

      - name: Diagnostic checks before build
        script: |
          cd android
          echo "=== PRE-BUILD DIAGNOSTICS ==="
          echo ""
          echo "1. Checking Java version:"
          java -version 2>&1 || echo "Java not found in PATH"
          echo ""
          echo "2. Checking JAVA_HOME:"
          echo "JAVA_HOME=$JAVA_HOME"
          if [ ! -z "$JAVA_HOME" ]; then
            "$JAVA_HOME/bin/java" -version 2>&1 || echo "Java at JAVA_HOME not working"
          fi
          echo ""
          echo "3. Checking Gradle wrapper:"
          ls -la gradlew* || echo "Gradle wrapper not found"
          echo ""
          echo "4. Testing Gradle can run:"
          ./gradlew --version 2>&1 | head -10 || echo "Gradle --version failed"
          echo ""
          echo "5. Testing Gradle can list tasks:"
          ./gradlew tasks --all 2>&1 | head -30 || echo "Gradle tasks failed"
          echo ""
          echo "6. Checking gradle.properties:"
          cat gradle.properties 2>&1 | head -20 || echo "gradle.properties not found"
          echo ""
          echo "7. Checking build.gradle files exist:"
          find . -name "build.gradle" -type f | head -10
          echo ""

      - name: Build Debug APK first (to verify build works)
        script: |
          cd android
          # Ensure JAVA_HOME is set
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || /usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
          fi
          if [ -z "$JAVA_HOME" ] || [ ! -f "$JAVA_HOME/bin/java" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17)
          fi
          export JAVA_HOME

          # Ensure gradle.properties has org.gradle.java.home set
          if [ -f gradle.properties ]; then
            if ! grep -q "^org\.gradle\.java\.home=" gradle.properties; then
              echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            fi
          else
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
          fi

          echo "=== Building Debug APK (to verify build works) ==="
          echo "Running: ./gradlew assembleDebug --stacktrace --info"
          echo ""
          echo "âš ï¸ If build fails, look for 'ğŸ“„ EXTRACTED ERROR MESSAGES' section below"
          echo ""

          # Build with output visible and captured
          set -o pipefail
          ./gradlew assembleDebug --stacktrace --info 2>&1 | tee debug-build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}

          # Immediately show if build failed (before detailed extraction)
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "ğŸš¨ğŸš¨ğŸš¨ BUILD FAILED! Extracting error messages... ğŸš¨ğŸš¨ğŸš¨"
            echo ""
            echo "=== QUICK ERROR SUMMARY ==="
            echo "Last 30 lines of build output (most likely to contain the error):"
            tail -n 30 debug-build.log
            echo ""
            echo "Looking for specific error patterns..."
            grep -i -E "error:|FAILURE|What went wrong|Execution failed" debug-build.log | tail -20 || echo "No obvious error patterns found in last check"
            echo ""
          fi

          echo ""
          echo "=== Build completed with exit code: $BUILD_EXIT_CODE ==="
          echo ""

          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            # Extract errors to a separate file for easy access
            echo "Extracting error messages..." > build-errors.txt
            
            echo "" >> build-errors.txt
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >> build-errors.txt
            echo "âŒ BUILD FAILED - ERROR EXTRACTION" >> build-errors.txt
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >> build-errors.txt
            echo "" >> build-errors.txt
            
            # Find the line number where "BUILD FAILED" appears
            FAIL_LINE=$(grep -n "BUILD FAILED" debug-build.log | tail -1 | cut -d: -f1)
            if [ ! -z "$FAIL_LINE" ]; then
              echo "Found 'BUILD FAILED' at line $FAIL_LINE" >> build-errors.txt
              echo "Showing 50 lines before and 200 lines after (error usually appears right after BUILD FAILED):" >> build-errors.txt
              echo "" >> build-errors.txt
              sed -n "$((FAIL_LINE - 50)),$((FAIL_LINE + 200))p" debug-build.log >> build-errors.txt
            fi
            
            echo "" >> build-errors.txt
            echo "=== FAILURE MESSAGES ===" >> build-errors.txt
            grep -A 30 "FAILURE:" debug-build.log >> build-errors.txt 2>/dev/null || echo "No FAILURE: found" >> build-errors.txt
            
            echo "" >> build-errors.txt
            echo "=== WHAT WENT WRONG ===" >> build-errors.txt
            grep -A 30 "What went wrong:" debug-build.log >> build-errors.txt 2>/dev/null || echo "No 'What went wrong:' found" >> build-errors.txt
            
            echo "" >> build-errors.txt
            echo "=== EXECUTION FAILED FOR TASK ===" >> build-errors.txt
            grep -B 10 -A 20 "Execution failed for task" debug-build.log >> build-errors.txt 2>/dev/null || echo "No task execution failures found" >> build-errors.txt
            
            echo "" >> build-errors.txt
            echo "=== FAILED TASKS ===" >> build-errors.txt
            grep "> Task :.*FAILED" debug-build.log >> build-errors.txt 2>/dev/null || echo "No failed tasks found" >> build-errors.txt
            
            echo "" >> build-errors.txt
            echo "=== ERROR PATTERNS ===" >> build-errors.txt
            grep -i -E "error|exception|failed|cannot|unable" debug-build.log | grep -v "at org.gradle" | head -50 >> build-errors.txt 2>/dev/null || echo "No error patterns found" >> build-errors.txt
            
            echo "" >> build-errors.txt
            echo "=== COMPILATION ERRORS ===" >> build-errors.txt
            grep -i -E "error:|error code|compilation error|cannot find symbol|package.*does not exist|class.*not found" debug-build.log >> build-errors.txt 2>/dev/null || echo "No compilation errors found" >> build-errors.txt
            
            echo "" >> build-errors.txt
            echo "=== LAST 50 LINES (MOST RECENT ERRORS) ===" >> build-errors.txt
            tail -n 50 debug-build.log >> build-errors.txt
            
            # Display the error file prominently
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âŒâŒâŒ BUILD FAILED WITH EXIT CODE $BUILD_EXIT_CODE âŒâŒâŒ"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“„ EXTRACTED ERROR MESSAGES (also saved to build-errors.txt):"
            echo ""
            cat build-errors.txt
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "=== LAST 150 LINES OF BUILD LOG (MOST RECENT) ==="
            tail -n 150 debug-build.log
            echo ""
            echo "ğŸ“‹ Full log: debug-build.log ($(wc -l < debug-build.log) lines)"
            echo "ğŸ“‹ Errors: build-errors.txt"
            exit 1
          fi

          echo "âœ… Build succeeded!"

          # Verify debug APK was created (only if build succeeded)
          echo ""
          echo "=== Verifying debug APK was created ==="
          if [ -f "app/build/outputs/apk/debug/app-debug.apk" ]; then
            echo "âœ… Debug APK created successfully!"
            ls -lh app/build/outputs/apk/debug/
          else
            echo "âš ï¸ Debug APK not found at expected location"
            echo "Searching for APK files..."
            find . -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found anywhere"
            echo ""
            echo "Checking build outputs directory:"
            ls -la app/build/outputs/ 2>/dev/null || echo "app/build/outputs does not exist"
            ls -la app/build/ 2>/dev/null || echo "app/build does not exist"
          fi

      - name: Build Android App Bundle
        script: |
          cd android
          # Ensure JAVA_HOME is set (environment variables don't persist between steps)
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || /usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
          fi
          if [ -z "$JAVA_HOME" ] || [ ! -f "$JAVA_HOME/bin/java" ]; then
            echo "âŒ ERROR: JAVA_HOME is not set or invalid!"
            echo "Attempting to find Java 17..."
            export JAVA_HOME=$(/usr/libexec/java_home -v 17)
          fi
          export JAVA_HOME
          echo "Building with JAVA_HOME: $JAVA_HOME"

          # Ensure gradle.properties has org.gradle.java.home set (it should from previous step, but verify)
          if [ -f gradle.properties ]; then
            if ! grep -q "^org\.gradle\.java\.home=" gradle.properties; then
              echo "Setting org.gradle.java.home in gradle.properties..."
              echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            fi
          else
            echo "Creating gradle.properties with org.gradle.java.home..."
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
          fi

          # Verify Java version
          echo "Java version:"
          "$JAVA_HOME/bin/java" -version

          # Clean build to ensure fresh state
          echo ""
          echo "=== Cleaning previous build ==="
          ./gradlew clean || true

          # Build with full error output
          echo ""
          echo "=== Building Android App Bundle (Release) ==="
          set -o pipefail
          ./gradlew bundleRelease --stacktrace --info 2>&1 | tee release-build.log
          BUNDLE_EXIT_CODE=${PIPESTATUS[0]}

          if [ $BUNDLE_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "âŒ Release build failed with exit code $BUNDLE_EXIT_CODE!"
            echo ""
            echo "=== FULL BUILD OUTPUT ==="
            cat release-build.log
            echo ""
            echo "=== Searching for specific errors ==="
            grep -i -A 10 -B 5 "error\|failed\|exception\|FAILURE" release-build.log | head -50 || echo "No obvious errors found"
            echo ""
            echo "âš ï¸ Release build failed. Trying to build debug bundle instead..."
            ./gradlew bundleDebug --stacktrace --info 2>&1 | tee debug-bundle.log
            DEBUG_BUNDLE_EXIT_CODE=${PIPESTATUS[0]}
            
            if [ $DEBUG_BUNDLE_EXIT_CODE -ne 0 ]; then
              echo ""
              echo "âŒ Debug bundle also failed!"
              echo "=== FULL DEBUG BUNDLE OUTPUT ==="
              cat debug-bundle.log
              exit 1
            else
              echo "âœ… Debug bundle built successfully!"
            fi
          else
            echo "âœ… Release bundle built successfully!"
          fi

          # Verify build artifacts were created (only if build succeeded)
          echo ""
          echo "=== Verifying build artifacts ==="
          echo "Checking for AAB files..."
          find app/build/outputs -name "*.aab" -type f 2>/dev/null | head -10 || echo "No AAB files found"
          echo ""
          echo "Checking for APK files..."
          find app/build/outputs -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"
          echo ""
          echo "Listing app/build/outputs directory structure:"
          ls -laR app/build/outputs/ 2>/dev/null | head -50 || echo "Outputs directory not found"
          echo ""
          echo "Full path to outputs:"
          pwd
          ls -la app/build/outputs/bundle/release/ 2>/dev/null || echo "Bundle release directory not found"
          ls -la app/build/outputs/bundle/debug/ 2>/dev/null || echo "Bundle debug directory not found"
          ls -la app/build/outputs/apk/release/ 2>/dev/null || echo "APK release directory not found"
          ls -la app/build/outputs/apk/debug/ 2>/dev/null || echo "APK debug directory not found"

      - name: Build Release APK (for testing)
        script: |
          cd android
          # Ensure JAVA_HOME is set (environment variables don't persist between steps)
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || /usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
          fi
          if [ -z "$JAVA_HOME" ] || [ ! -f "$JAVA_HOME/bin/java" ]; then
            echo "âŒ ERROR: JAVA_HOME is not set or invalid!"
            export JAVA_HOME=$(/usr/libexec/java_home -v 17)
          fi
          export JAVA_HOME
          echo "Building with JAVA_HOME: $JAVA_HOME"

          # Ensure gradle.properties has org.gradle.java.home set
          if [ -f gradle.properties ]; then
            if ! grep -q "^org\.gradle\.java\.home=" gradle.properties; then
              echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            fi
          else
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
          fi

          # Build with full error output
          echo ""
          echo "=== Building Android Release APK ==="
          set -o pipefail
          ./gradlew assembleRelease --stacktrace --info 2>&1 | tee release-apk.log
          RELEASE_APK_EXIT_CODE=${PIPESTATUS[0]}

          if [ $RELEASE_APK_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "âŒ Release APK build failed with exit code $RELEASE_APK_EXIT_CODE!"
            echo ""
            echo "=== FULL BUILD OUTPUT ==="
            cat release-apk.log
            echo ""
            echo "=== Searching for specific errors ==="
            grep -i -A 10 -B 5 "error\|failed\|exception\|FAILURE" release-apk.log | head -50 || echo "No obvious errors found"
            echo ""
            echo "âš ï¸ Release APK build failed. Debug APK should already be available from earlier step."
            # Don't exit - debug APK is already built
          else
            echo "âœ… Release APK built successfully!"
          fi

          # Verify build artifacts were created
          echo ""
          echo "=== Verifying build artifacts ==="
          echo "Checking for APK files..."
          find app/build/outputs -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"
          echo ""
          echo "Listing app/build/outputs directory structure:"
          ls -laR app/build/outputs/ 2>/dev/null | head -50 || echo "Outputs directory not found"
          echo ""
          echo "Full path to outputs:"
          pwd
          ls -la app/build/outputs/apk/release/ 2>/dev/null || echo "APK release directory not found"
          ls -la app/build/outputs/apk/debug/ 2>/dev/null || echo "APK debug directory not found"

      - name: Verify artifacts from workspace root
        script: |
          echo "=== Verifying artifacts from workspace root ==="
          echo "Current directory: $(pwd)"
          echo ""
          echo "Looking for AAB files:"
          find . -name "*.aab" -type f 2>/dev/null | head -10 || echo "No AAB files found"
          echo ""
          echo "Looking for APK files:"
          find . -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"
          echo ""
          echo "Checking android/app/build/outputs:"
          if [ -d "android/app/build/outputs" ]; then
            echo "âœ… Outputs directory exists"
            ls -laR android/app/build/outputs/ | head -100
          else
            echo "âŒ Outputs directory does not exist!"
            echo "Listing android/app/build directory:"
            ls -la android/app/build/ 2>/dev/null || echo "android/app/build does not exist"
          fi

      - name: Artifact Summary and Download Instructions
        script: |
          echo "=========================================="
          echo "ğŸ“¦ ARTIFACT SUMMARY"
          echo "=========================================="
          echo ""
          echo "Finding all APK and AAB files:"
          find . -type f \( -name "*.apk" -o -name "*.aab" \) 2>/dev/null | while read file; do
            echo "  âœ… Found: $file ($(du -h "$file" | cut -f1))"
          done || echo "  âš ï¸ No APK/AAB files found"
          echo ""
          echo "=========================================="
          echo "ğŸ“¥ HOW TO DOWNLOAD ARTIFACTS"
          echo "=========================================="
          echo ""
          echo "After a successful build, download your app files from Codemagic:"
          echo ""
          echo "1. Go to your Codemagic dashboard"
          echo "2. Click on the completed build"
          echo "3. Scroll to the 'Artifacts' section"
          echo "4. Click the download button next to:"
          echo "   - *.apk files (for direct installation)"
          echo "   - *.aab files (for Google Play Store upload)"
          echo ""
          echo "Or use the Codemagic CLI:"
          echo "  codemagic-cli builds artifacts <build-id>"
          echo ""
          echo "Artifacts are automatically collected from:"
          echo "  - android/app/build/outputs/**/*.apk"
          echo "  - android/app/build/outputs/**/*.aab"
          echo ""

    artifacts:
      - android/app/build/outputs/**/*.aab
      - android/app/build/outputs/**/*.apk
      - android/app/build/outputs/bundle/**/*
      - android/app/build/outputs/apk/**/*
      - android/app/build/outputs/**/debug/**
      - android/app/build/outputs/**/release/**
      - android/build-errors.txt
      - android/debug-build.log
      - android/release-build.log
      - android/debug-bundle.log
      - android/release-apk.log

    publishing:
      email:
        recipients:
          - justin@fluidinvestmentgroup.com
        notify:
          success: true
          failure: true

  ios-build:
    name: iOS Build
    max_build_duration: 120
    instance_type: mac_mini_m2
    environment:
      groups:
        - ios_certificates
        - app_store_connect
      node: 20
      vars:
        BUNDLE_ID: "com.kidscallhome.app"
        APP_NAME: "Kids Call Home"
        XCODE_WORKSPACE: "App.xcworkspace"  # Capacitor iOS uses workspace
        XCODE_SCHEME: "App"  # Default Capacitor scheme
        APP_STORE_APPLE_ID: "6756827237"  # From App Store Connect (confirmed in IOS_READINESS_STATUS.md)
      xcode: latest
      cocoapods: default
      ios_signing:
        # IMPORTANT: If you get "No matching profiles found" error:
        # 1. Go to Codemagic â†’ Teams â†’ Code Signing â†’ ios_certificates group
        # 2. Ensure you have:
        #    - A Distribution Certificate (not Development)
        #    - An App Store Provisioning Profile (not Development/Ad Hoc)
        #    - The provisioning profile must be for bundle ID: com.kidscallhome.app
        # 3. If profiles are missing, generate them in Codemagic or upload from Apple Developer
        # 4. Verify the bundle ID in the profile matches exactly: com.kidscallhome.app
        distribution_type: app_store  # or 'development' for testing
        bundle_identifier: "com.kidscallhome.app"
    scripts:
      - name: Install dependencies
        script: |
          npm ci

      - name: Build web app
        script: |
          npm run build

      - name: Generate iOS platform
        script: |
          echo "=== Generating iOS Platform ==="
          echo "Current directory: $(pwd)"
          echo ""
          
          # Check if ios/App/Podfile exists (indicates full iOS project)
          if [ -f "ios/App/Podfile" ]; then
            echo "âœ… iOS project already exists with Podfile"
          else
            echo "ğŸ“± iOS project not complete, generating it now..."
            
            # Remove partial ios directory if it exists (just templates)
            if [ -d "ios" ]; then
              echo "Removing partial ios directory..."
              # Save any template files we might need
              if [ -f "ios/Info.plist.template" ]; then
                cp ios/Info.plist.template /tmp/Info.plist.template.backup
              fi
              rm -rf ios
            fi
            
            # Add iOS platform fresh
            echo "Running: npx cap add ios"
            npx cap add ios
            
            if [ $? -ne 0 ]; then
              echo "âŒ Failed to add iOS platform!"
              exit 1
            fi
            
            echo "âœ… iOS project generated"
          fi
          
          # List the ios directory structure
          echo ""
          echo "iOS directory structure:"
          ls -la ios/ 2>/dev/null || echo "ios/ directory not found"
          echo ""
          if [ -d "ios/App" ]; then
            echo "ios/App directory:"
            ls -la ios/App/ 2>/dev/null || echo "ios/App is empty"
          fi

      - name: Sync Capacitor iOS
        script: |
          echo "=== Syncing Capacitor iOS Project ==="
          echo "Current directory: $(pwd)"
          echo ""
          
          # Sync web assets and native plugins
          echo "Running: npx cap sync ios"
          npx cap sync ios
          
          if [ $? -ne 0 ]; then
            echo "âŒ Capacitor sync failed!"
            echo ""
            echo "Attempting recovery..."
            
            # Try to add iOS platform if sync failed
            if [ ! -f "ios/App/Podfile" ]; then
              echo "Podfile missing, trying to regenerate iOS project..."
              rm -rf ios
              npx cap add ios
              npx cap sync ios
            fi
          fi
          
          # Verify key files exist
          echo ""
          echo "=== Verifying iOS Project Structure ==="
          
          if [ ! -d "ios/App" ]; then
            echo "âŒ ios/App directory not found!"
            exit 1
          fi
          echo "âœ… ios/App directory exists"
          ls -la ios/App/ | head -20
          
          # Check for Podfile (critical)
          if [ ! -f "ios/App/Podfile" ]; then
            echo "âŒ Podfile not found at ios/App/Podfile!"
            echo ""
            echo "This is a critical error. The iOS project was not generated correctly."
            echo "Searching for any Podfile..."
            find ios -name "Podfile" -type f 2>/dev/null || echo "No Podfile found anywhere"
            exit 1
          fi
          echo "âœ… Podfile found at ios/App/Podfile"
          
          # Check for Xcode project
          if [ -d "ios/App/App.xcodeproj" ]; then
            echo "âœ… Xcode project found"
          else
            echo "âš ï¸ Xcode project not found"
            find ios -name "*.xcodeproj" -type d 2>/dev/null || echo "No xcodeproj found"
          fi
          
          echo ""
          echo "âœ… Capacitor iOS sync completed"

      - name: Configure iOS permissions in Info.plist
        script: |
          # Ensure Info.plist exists and has required permissions
          INFO_PLIST="ios/App/App/Info.plist"
          
          if [ ! -f "$INFO_PLIST" ]; then
            echo "âš ï¸ Info.plist not found at $INFO_PLIST"
            echo "Searching for Info.plist..."
            find ios -name "Info.plist" -type f 2>/dev/null | head -5 || echo "No Info.plist found"
            echo "Will try to configure after CocoaPods install"
          else
            echo "ğŸ“ Configuring iOS permissions in $INFO_PLIST..."
            
            # Use PlistBuddy to add/update permissions (macOS tool)
            /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true
            
            /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSMicrophoneUsageDescription 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true
            
            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || true
            
            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || true
            
            /usr/libexec/PlistBuddy -c "Add :NSUserNotificationsUsageDescription string 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSUserNotificationsUsageDescription 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || true
            
            echo "âœ… iOS permissions configured"
          fi

      - name: Install CocoaPods dependencies
        script: |
          echo "=== Installing CocoaPods Dependencies ==="
          echo "Current directory: $(pwd)"
          echo ""
          
          # Check if iOS directory exists
          if [ ! -d "ios" ]; then
            echo "âŒ iOS directory not found!"
            echo "This should have been created by 'Sync Capacitor iOS' step"
            exit 1
          fi
          
          # Find the Podfile location
          PODFILE_PATH=$(find ios -name "Podfile" -type f | head -1)
          
          if [ -z "$PODFILE_PATH" ]; then
            echo "âš ï¸ Podfile not found. Checking iOS directory structure..."
            echo ""
            echo "iOS directory contents:"
            ls -la ios/ 2>/dev/null || echo "ios/ directory is empty or doesn't exist"
            echo ""
            
            # Check if ios/App exists
            if [ -d "ios/App" ]; then
              echo "ios/App directory exists. Contents:"
              ls -la ios/App/ 2>/dev/null || echo "ios/App is empty"
              echo ""
              
              # Try to create Podfile if it's missing (Capacitor should have created it)
              echo "âš ï¸ Podfile missing. This might indicate Capacitor sync didn't complete properly."
              echo "Attempting to sync again..."
              npx cap sync ios
              
              # Check again
              PODFILE_PATH=$(find ios -name "Podfile" -type f | head -1)
              if [ -z "$PODFILE_PATH" ]; then
                echo "âŒ Podfile still not found after sync!"
                exit 1
              fi
            else
              echo "âŒ ios/App directory not found!"
              echo "Capacitor iOS project was not created properly."
              exit 1
            fi
          fi
          
          # Get the directory containing the Podfile
          PODFILE_DIR=$(dirname "$PODFILE_PATH")
          echo "âœ… Found Podfile at: $PODFILE_PATH"
          echo "Changing to directory: $PODFILE_DIR"
          cd "$PODFILE_DIR"
          
          # Verify CocoaPods is installed
          echo ""
          echo "=== Verifying CocoaPods ==="
          if ! command -v pod &> /dev/null; then
            echo "âŒ CocoaPods not found in PATH!"
            echo "Codemagic should have CocoaPods installed. Checking version..."
            which pod || echo "pod command not found"
            exit 1
          fi
          
          POD_VERSION=$(pod --version 2>/dev/null || echo "unknown")
          echo "âœ… CocoaPods version: $POD_VERSION"
          
          echo ""
          echo "=== Running pod install ==="
          pod install
          
          if [ $? -ne 0 ]; then
            echo "âŒ pod install failed!"
            echo ""
            echo "Troubleshooting:"
            echo "1. Check if CocoaPods is installed: pod --version"
            echo "2. Try updating CocoaPods: pod repo update"
            echo "3. Check Podfile syntax"
            exit 1
          fi
          
          echo "âœ… CocoaPods dependencies installed successfully"

      - name: Configure iOS permissions after CocoaPods (if needed)
        script: |
          # Try again after CocoaPods install in case Info.plist was generated
          INFO_PLIST="ios/App/App/Info.plist"
          if [ -f "$INFO_PLIST" ]; then
            echo "ğŸ“ Configuring iOS permissions (post-CocoaPods)..."
            /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSMicrophoneUsageDescription 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSUserNotificationsUsageDescription string 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSUserNotificationsUsageDescription 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || true
            echo "âœ… iOS permissions configured"
          fi

      - name: Verify and set bundle identifier in Xcode project
        script: |
          cd ios/App
          echo "=== Verifying Bundle Identifier ==="
          echo "Expected bundle ID: $BUNDLE_ID"
          echo ""
          
          # Find the project.pbxproj file
          PROJECT_FILE=$(find . -name "*.xcodeproj" -type d | head -1)
          if [ -z "$PROJECT_FILE" ]; then
            echo "âŒ Xcode project not found!"
            echo "Searching for Xcode projects..."
            find . -name "*.xcodeproj" -type d 2>/dev/null || echo "No .xcodeproj found"
            exit 1
          fi
          
          PBXPROJ="$PROJECT_FILE/project.pbxproj"
          echo "Found project: $PROJECT_FILE"
          echo "Reading: $PBXPROJ"
          echo ""
          
          # Debug: Show all PRODUCT_BUNDLE_IDENTIFIER lines (Capacitor may use different formats)
          echo "=== All PRODUCT_BUNDLE_IDENTIFIER lines in project ==="
          grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -20 || echo "No PRODUCT_BUNDLE_IDENTIFIER found"
          echo ""
          
          # Capacitor projects may use format: PRODUCT_BUNDLE_IDENTIFIER = com.example.app; (no quotes)
          # or: PRODUCT_BUNDLE_IDENTIFIER = "com.example.app"; (with quotes)
          # Extract bundle ID handling both formats
          CURRENT_BUNDLE_ID=$(grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -1 | sed 's/.*PRODUCT_BUNDLE_IDENTIFIER = //' | sed 's/[";]//g' | tr -d '[:space:]')
          echo "Current bundle ID in project: '$CURRENT_BUNDLE_ID'"
          
          # Update bundle identifier if it doesn't match or is empty
          if [ "$CURRENT_BUNDLE_ID" != "$BUNDLE_ID" ]; then
            echo "âš ï¸ Bundle ID mismatch! Updating all instances to $BUNDLE_ID..."
            
            # Update both quoted and unquoted formats
            # Format 1: PRODUCT_BUNDLE_IDENTIFIER = "something";
            sed -i '' "s/PRODUCT_BUNDLE_IDENTIFIER = \"[^\"]*\"/PRODUCT_BUNDLE_IDENTIFIER = \"$BUNDLE_ID\"/g" "$PBXPROJ"
            # Format 2: PRODUCT_BUNDLE_IDENTIFIER = something; (no quotes, Capacitor default)
            sed -i '' "s/PRODUCT_BUNDLE_IDENTIFIER = [^;\"]*;/PRODUCT_BUNDLE_IDENTIFIER = $BUNDLE_ID;/g" "$PBXPROJ"
            
            echo "âœ… Bundle ID updated in project.pbxproj"
            
            # Verify the update worked
            echo ""
            echo "After update - PRODUCT_BUNDLE_IDENTIFIER lines:"
            grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -10 || echo "No lines found"
          else
            echo "âœ… Bundle ID matches"
          fi
          
          # Info.plist typically uses $(PRODUCT_BUNDLE_IDENTIFIER) variable, which is fine
          if [ -f "App/Info.plist" ]; then
            echo ""
            echo "Checking Info.plist..."
            INFO_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "App/Info.plist" 2>/dev/null || echo "")
            echo "Info.plist CFBundleIdentifier: $INFO_BUNDLE_ID"
            
            # If it uses $(PRODUCT_BUNDLE_IDENTIFIER), that's correct - it will inherit from project
            if [ "$INFO_BUNDLE_ID" = '$(PRODUCT_BUNDLE_IDENTIFIER)' ]; then
              echo "âœ… Info.plist uses project variable (correct)"
            elif [ "$INFO_BUNDLE_ID" != "$BUNDLE_ID" ] && [ ! -z "$INFO_BUNDLE_ID" ]; then
              echo "âš ï¸ Updating Info.plist bundle ID to use project variable..."
              /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier \$(PRODUCT_BUNDLE_IDENTIFIER)" "App/Info.plist" 2>/dev/null || true
              echo "âœ… Info.plist updated to use \$(PRODUCT_BUNDLE_IDENTIFIER)"
            fi
          fi
          
          echo ""
          echo "=== Final Bundle ID Verification ==="
          FINAL_BUNDLE_ID=$(grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -1 | sed 's/.*PRODUCT_BUNDLE_IDENTIFIER = //' | sed 's/[";]//g' | tr -d '[:space:]')
          echo "Final bundle ID: '$FINAL_BUNDLE_ID'"
          
          if [ "$FINAL_BUNDLE_ID" != "$BUNDLE_ID" ]; then
            echo "âš ï¸ WARNING: Bundle ID may not have been updated correctly"
            echo "Expected: $BUNDLE_ID"
            echo "Found: $FINAL_BUNDLE_ID"
            echo ""
            echo "Attempting to add bundle ID if missing..."
            # If no bundle ID exists, we may need to add it - but this is unusual
            # For now, continue and let Xcode/signing handle it
            echo "Continuing with build - signing step will set the correct bundle ID"
          else
            echo "âœ… Bundle ID verification passed"
          fi

      - name: List available provisioning profiles
        script: |
          echo "=== Available Provisioning Profiles ==="
          echo "Checking for profiles matching bundle ID: $BUNDLE_ID"
          echo ""
          
          # List all provisioning profiles
          if [ -d ~/Library/MobileDevice/Provisioning\ Profiles ]; then
            echo "Provisioning profiles directory exists"
            ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ | head -20 || echo "No profiles found"
            echo ""
            
            # Try to extract bundle IDs from profiles
            echo "Extracting bundle IDs from profiles..."
            for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
              if [ -f "$profile" ]; then
                BUNDLE_ID_IN_PROFILE=$(security cms -D -i "$profile" 2>/dev/null | grep -A 1 "application-identifier" | grep -o '"[^"]*"' | head -1 | sed 's/"//g' | sed 's/.*\.//' || echo "")
                if [ ! -z "$BUNDLE_ID_IN_PROFILE" ]; then
                  echo "  Profile: $(basename "$profile")"
                  echo "    Bundle ID: $BUNDLE_ID_IN_PROFILE"
                fi
              fi
            done
          else
            echo "âš ï¸ Provisioning profiles directory not found"
          fi
          
          echo ""
          echo "=== Codemagic Environment Check ==="
          echo "BUNDLE_ID: $BUNDLE_ID"
          echo "Distribution type: app_store"
          echo ""
          echo "âš ï¸ If no matching profiles are found above, you need to:"
          echo "1. Go to Codemagic â†’ Teams â†’ Code Signing"
          echo "2. Ensure the 'ios_certificates' group contains:"
          echo "   - A Distribution Certificate"
          echo "   - An App Store Provisioning Profile for bundle ID: $BUNDLE_ID"
          echo "3. The provisioning profile must match exactly: $BUNDLE_ID"

      - name: Set up provisioning profiles settings on Xcode project
        script: |
          echo "=== Setting up provisioning profiles ==="
          echo "Bundle ID: $BUNDLE_ID"
          echo "Distribution type: app_store"
          echo ""
          
          # Use Codemagic's xcode-project command to set up profiles
          xcode-project use-profiles || {
            echo "âŒ Failed to set up provisioning profiles"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify 'ios_certificates' group exists in Codemagic"
            echo "2. Ensure it contains an App Store provisioning profile for: $BUNDLE_ID"
            echo "3. Check that the certificate and profile are valid and not expired"
            echo "4. Try regenerating the certificate/profile in Codemagic if needed"
            exit 1
          }
          
          echo "âœ… Provisioning profiles configured"

      - name: Increment build number (if App Store Connect API key configured)
        script: |
          if [ ! -z "$APP_STORE_APPLE_ID" ] && [ ! -z "$APP_STORE_CONNECT_API_KEY_ID" ]; then
            cd ios/App
            LATEST_BUILD_NUMBER=$(app-store-connect get-latest-app-store-build-number "$APP_STORE_APPLE_ID" || echo "0")
            agvtool new-version -all $(($LATEST_BUILD_NUMBER + 1))
          else
            echo "âš ï¸ Skipping build number increment - App Store Connect not configured"
          fi

      - name: Build IPA for distribution
        script: |
          xcode-project build-ipa \
            --workspace "ios/App/$XCODE_WORKSPACE" \
            --scheme "$XCODE_SCHEME"

    artifacts:
      - build/ios/ipa/*.ipa
      - /tmp/xcodebuild_logs/*.log
      - $HOME/Library/Developer/Xcode/DerivedData/**/Build/**/*.app
      - $HOME/Library/Developer/Xcode/DerivedData/**/Build/**/*.dSYM

    publishing:
      email:
        recipients:
          - justin@fluidinvestmentgroup.com
        notify:
          success: true
          failure: true
      # Uncomment and configure after setting up App Store Connect API key
      # app_store_connect:
      #   auth: integration
      #   submit_to_testflight: true
      #   beta_groups:
      #     - "Internal Testers"
      #   submit_to_app_store: false

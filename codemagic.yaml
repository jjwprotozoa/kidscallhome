# codemagic.yaml
# Codemagic CI/CD configuration for KidsCallHome native apps (Android & iOS)
# Capacitor-based PWA wrapped in native containers

workflows:
  android-build:
    name: Android Build
    max_build_duration: 120
    instance_type: mac_mini_m1
    environment:
      groups:
        - android_keystore
        - google_play
      node: 20
      java: 17
      vars:
        PACKAGE_NAME: "com.kidscallhome.app"
        APP_NAME: "Kids Call Home"
    scripts:
      - name: Install dependencies
        script: |
          npm ci

      - name: Build web app
        script: |
          npm run build

      - name: Sync Capacitor
        script: |
          npx cap sync android

      - name: Set up Android keystore
        script: |
          echo "=== Setting up Android Keystore for Signing ==="
          echo ""

          # Check for keystore environment variables
          KEYSTORE_PATH=""
          KEYSTORE_PASSWORD=""
          KEY_ALIAS=""
          KEY_PASSWORD=""

          # Try to find keystore file from environment variables or common locations
          if [ ! -z "$CM_KEYSTORE_PATH" ] && [ -f "$CM_KEYSTORE_PATH" ]; then
            KEYSTORE_PATH="$CM_KEYSTORE_PATH"
            echo "âœ… Found keystore at CM_KEYSTORE_PATH: $KEYSTORE_PATH"
          elif [ ! -z "$CM_KEYSTORE" ] && [ -f "$CM_KEYSTORE" ]; then
            KEYSTORE_PATH="$CM_KEYSTORE"
            echo "âœ… Found keystore at CM_KEYSTORE: $KEYSTORE_PATH"
          else
            # Try common Codemagic file locations
            if [ -f "$HOME/keystore.jks" ]; then
              KEYSTORE_PATH="$HOME/keystore.jks"
              echo "âœ… Found keystore at $HOME/keystore.jks"
            elif [ -f "$HOME/upload-keystore.jks" ]; then
              KEYSTORE_PATH="$HOME/upload-keystore.jks"
              echo "âœ… Found keystore at $HOME/upload-keystore.jks"
            elif [ -f "./keystore.jks" ]; then
              KEYSTORE_PATH="./keystore.jks"
              echo "âœ… Found keystore at ./keystore.jks"
            elif [ -f "./upload-keystore.jks" ]; then
              KEYSTORE_PATH="./upload-keystore.jks"
              echo "âœ… Found keystore at ./upload-keystore.jks"
            fi
          fi

          # Get passwords and alias from environment variables
          if [ ! -z "$CM_KEYSTORE_PASSWORD" ]; then
            KEYSTORE_PASSWORD="$CM_KEYSTORE_PASSWORD"
          elif [ ! -z "$KEYSTORE_PASSWORD" ]; then
            KEYSTORE_PASSWORD="$KEYSTORE_PASSWORD"
          fi

          if [ ! -z "$CM_KEY_ALIAS" ]; then
            KEY_ALIAS="$CM_KEY_ALIAS"
          elif [ ! -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="$KEY_ALIAS"
          else
            # Default alias if not set
            KEY_ALIAS="upload"
          fi

          if [ ! -z "$CM_KEY_PASSWORD" ]; then
            KEY_PASSWORD="$CM_KEY_PASSWORD"
          elif [ ! -z "$KEY_PASSWORD" ]; then
            KEY_PASSWORD="$KEY_PASSWORD"
          fi

          # If keystore path is found but passwords not set, try to use same value for both
          if [ ! -z "$KEYSTORE_PATH" ] && [ -z "$KEYSTORE_PASSWORD" ] && [ ! -z "$CM_KEYSTORE_PASSWORD" ]; then
            KEYSTORE_PASSWORD="$CM_KEYSTORE_PASSWORD"
            if [ -z "$KEY_PASSWORD" ]; then
              KEY_PASSWORD="$CM_KEYSTORE_PASSWORD"
            fi
          fi

          # Verify all required values are set
          if [ -z "$KEYSTORE_PATH" ] || [ ! -f "$KEYSTORE_PATH" ]; then
            echo "âš ï¸ Keystore file not found. Checking environment variables:"
            echo "  CM_KEYSTORE_PATH: ${CM_KEYSTORE_PATH:-not set}"
            echo "  CM_KEYSTORE: ${CM_KEYSTORE:-not set}"
            echo ""
            echo "âš ï¸ WARNING: Keystore not configured. Release builds will not be signed."
            echo "To configure keystore signing:"
            echo "1. Go to Codemagic â†’ Teams â†’ Code Signing"
            echo "2. Find or create the 'android_keystore' environment group"
            echo "3. Upload your .jks keystore file"
            echo "4. Add environment variables:"
            echo "   - CM_KEYSTORE_PATH: Path to the uploaded keystore file"
            echo "   - CM_KEYSTORE_PASSWORD: Keystore password"
            echo "   - CM_KEY_ALIAS: Key alias (default: upload)"
            echo "   - CM_KEY_PASSWORD: Key password (can be same as keystore password)"
            echo ""
            echo "Continuing without signing configuration (debug builds will work)..."
            exit 0
          fi

          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "âš ï¸ WARNING: CM_KEYSTORE_PASSWORD not set. Cannot configure signing."
            echo "Continuing without signing configuration..."
            exit 0
          fi

          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="upload"
            echo "âš ï¸ Using default key alias: $KEY_ALIAS"
          fi

          if [ -z "$KEY_PASSWORD" ]; then
            KEY_PASSWORD="$KEYSTORE_PASSWORD"
            echo "âš ï¸ Using keystore password as key password"
          fi

          echo ""
          echo "âœ… Keystore configuration found:"
          echo "  Keystore file: $KEYSTORE_PATH"
          echo "  Key alias: $KEY_ALIAS"
          echo ""

          # Copy keystore to android directory
          KEYSTORE_DEST="android/upload-keystore.jks"
          echo "Copying keystore to: $KEYSTORE_DEST"
          mkdir -p android
          cp "$KEYSTORE_PATH" "$KEYSTORE_DEST"

          if [ ! -f "$KEYSTORE_DEST" ]; then
            echo "âŒ ERROR: Failed to copy keystore file!"
            exit 1
          fi

          echo "âœ… Keystore copied successfully"

          # Create keystore.properties file in android directory
          KEYSTORE_PROPERTIES="android/keystore.properties"
          echo "Creating keystore.properties file..."

          printf "storeFile=upload-keystore.jks\nstorePassword=%s\nkeyAlias=%s\nkeyPassword=%s\n" \
            "$KEYSTORE_PASSWORD" \
            "$KEY_ALIAS" \
            "$KEY_PASSWORD" > "$KEYSTORE_PROPERTIES"

          if [ ! -f "$KEYSTORE_PROPERTIES" ]; then
            echo "âŒ ERROR: Failed to create keystore.properties file!"
            exit 1
          fi

          echo "âœ… keystore.properties created"
          echo ""
          echo "Verifying keystore.properties contents (without passwords):"
          sed 's/Password=.*/Password=***/' "$KEYSTORE_PROPERTIES" | sed 's/storePassword=.*/storePassword=***/'
          echo ""
          echo "âœ… Keystore setup complete - AAB will be signed during build"

      - name: Verify Java version and configure Gradle
        script: |
          echo "=== Java Environment Setup ==="
          echo "Java version:"
          java -version
          echo ""
          echo "JAVA_HOME before: $JAVA_HOME"

          # Ensure JAVA_HOME is set and points to Java 17
          # Codemagic sets java: 17, but JAVA_HOME might not be set
          if [ -z "$JAVA_HOME" ]; then
            # Try to find Java 17 using macOS java_home utility
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || echo "")
            if [ -z "$JAVA_HOME" ]; then
              # Fallback: find any Java 17+ installation
              export JAVA_HOME=$(/usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
            fi
            echo "Set JAVA_HOME to: $JAVA_HOME"
          fi

          # Verify JAVA_HOME points to a valid Java 17 installation
          if [ ! -z "$JAVA_HOME" ] && [ -f "$JAVA_HOME/bin/java" ]; then
            echo "JAVA_HOME after: $JAVA_HOME"
            echo "Java version from JAVA_HOME:"
            "$JAVA_HOME/bin/java" -version
            JAVA_VERSION_OUTPUT=$("$JAVA_HOME/bin/java" -version 2>&1)
            if echo "$JAVA_VERSION_OUTPUT" | grep -qE 'version "1\.[0-8]\.'; then
              echo "âŒ ERROR: JAVA_HOME points to Java 8 or earlier!"
              echo "Java version output: $JAVA_VERSION_OUTPUT"
              exit 1
            fi
            echo "âœ… Java version is 11+"
          else
            echo "âŒ ERROR: JAVA_HOME is not set or invalid!"
            echo "Please ensure java: 17 is set in Codemagic environment"
            exit 1
          fi

          # Export JAVA_HOME for this script step
          export JAVA_HOME

          # Configure Gradle to use Java 17
          cd android
          chmod +x ./gradlew

          # Stop any existing Gradle daemons (they might be using Java 8)
          echo ""
          echo "=== Stopping Gradle daemons ==="
          ./gradlew --stop || true
          echo "âœ… Gradle daemons stopped"

          # Set org.gradle.java.home in gradle.properties to ensure Gradle uses Java 17
          # This is critical for buildscript classpath resolution
          echo ""
          echo "=== Configuring Gradle to use Java 17 ==="
          if [ -f gradle.properties ]; then
            # Remove any existing org.gradle.java.home line (macOS compatible sed)
            sed -i '' '/^org\.gradle\.java\.home=/d' gradle.properties 2>/dev/null || \
            sed -i.bak '/^org\.gradle\.java\.home=/d' gradle.properties 2>/dev/null || \
            grep -v '^org\.gradle\.java\.home=' gradle.properties > gradle.properties.tmp && mv gradle.properties.tmp gradle.properties
            # Add the correct Java home
            echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            echo "âœ… Updated gradle.properties with org.gradle.java.home=$JAVA_HOME"
            echo "Verification - org.gradle.java.home setting:"
            grep "org.gradle.java.home" gradle.properties || echo "âš ï¸ Warning: org.gradle.java.home not found in gradle.properties"
          else
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
            echo "âœ… Created gradle.properties with org.gradle.java.home=$JAVA_HOME"
          fi

          # Verify Gradle wrapper will use correct Java
          echo ""
          echo "=== Verifying Gradle wrapper configuration ==="
          echo "Gradle wrapper will use: $JAVA_HOME/bin/java"

      - name: Diagnostic checks before build
        script: |
          cd android
          echo "=== PRE-BUILD DIAGNOSTICS ==="
          echo ""
          echo "1. Checking Java version:"
          java -version 2>&1 || echo "Java not found in PATH"
          echo ""
          echo "2. Checking JAVA_HOME:"
          echo "JAVA_HOME=$JAVA_HOME"
          if [ ! -z "$JAVA_HOME" ]; then
            "$JAVA_HOME/bin/java" -version 2>&1 || echo "Java at JAVA_HOME not working"
          fi
          echo ""
          echo "3. Checking Gradle wrapper:"
          ls -la gradlew* || echo "Gradle wrapper not found"
          echo ""
          echo "4. Testing Gradle can run:"
          ./gradlew --version 2>&1 | head -10 || echo "Gradle --version failed"
          echo ""
          echo "5. Testing Gradle can list tasks:"
          ./gradlew tasks --all 2>&1 | head -30 || echo "Gradle tasks failed"
          echo ""
          echo "6. Checking gradle.properties:"
          cat gradle.properties 2>&1 | head -20 || echo "gradle.properties not found"
          echo ""
          echo "7. Checking build.gradle files exist:"
          find . -name "build.gradle" -type f | head -10
          echo ""

      - name: Build Debug APK first (to verify build works)
        script: |
          cd android
          # Ensure JAVA_HOME is set
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || /usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
          fi
          if [ -z "$JAVA_HOME" ] || [ ! -f "$JAVA_HOME/bin/java" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17)
          fi
          export JAVA_HOME

          # Ensure gradle.properties has org.gradle.java.home set
          if [ -f gradle.properties ]; then
            if ! grep -q "^org\.gradle\.java\.home=" gradle.properties; then
              echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            fi
          else
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
          fi

          echo "=== Building Debug APK (to verify build works) ==="
          echo "Running: ./gradlew assembleDebug --stacktrace --info"
          echo ""
          echo "âš ï¸ If build fails, look for 'ğŸ“„ EXTRACTED ERROR MESSAGES' section below"
          echo ""

          # Build with output visible and captured
          set -o pipefail
          ./gradlew assembleDebug --stacktrace --info 2>&1 | tee debug-build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}

          # Immediately show if build failed (before detailed extraction)
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "ğŸš¨ğŸš¨ğŸš¨ BUILD FAILED! Extracting error messages... ğŸš¨ğŸš¨ğŸš¨"
            echo ""
            echo "=== QUICK ERROR SUMMARY ==="
            echo "Last 30 lines of build output (most likely to contain the error):"
            tail -n 30 debug-build.log
            echo ""
            echo "Looking for specific error patterns..."
            grep -i -E "error:|FAILURE|What went wrong|Execution failed" debug-build.log | tail -20 || echo "No obvious error patterns found in last check"
            echo ""
          fi

          echo ""
          echo "=== Build completed with exit code: $BUILD_EXIT_CODE ==="
          echo ""

          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            # Extract errors to a separate file for easy access
            echo "Extracting error messages..." > build-errors.txt

            echo "" >> build-errors.txt
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >> build-errors.txt
            echo "âŒ BUILD FAILED - ERROR EXTRACTION" >> build-errors.txt
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >> build-errors.txt
            echo "" >> build-errors.txt

            # Find the line number where "BUILD FAILED" appears
            FAIL_LINE=$(grep -n "BUILD FAILED" debug-build.log | tail -1 | cut -d: -f1)
            if [ ! -z "$FAIL_LINE" ]; then
              echo "Found 'BUILD FAILED' at line $FAIL_LINE" >> build-errors.txt
              echo "Showing 50 lines before and 200 lines after (error usually appears right after BUILD FAILED):" >> build-errors.txt
              echo "" >> build-errors.txt
              sed -n "$((FAIL_LINE - 50)),$((FAIL_LINE + 200))p" debug-build.log >> build-errors.txt
            fi

            echo "" >> build-errors.txt
            echo "=== FAILURE MESSAGES ===" >> build-errors.txt
            grep -A 30 "FAILURE:" debug-build.log >> build-errors.txt 2>/dev/null || echo "No FAILURE: found" >> build-errors.txt

            echo "" >> build-errors.txt
            echo "=== WHAT WENT WRONG ===" >> build-errors.txt
            grep -A 30 "What went wrong:" debug-build.log >> build-errors.txt 2>/dev/null || echo "No 'What went wrong:' found" >> build-errors.txt

            echo "" >> build-errors.txt
            echo "=== EXECUTION FAILED FOR TASK ===" >> build-errors.txt
            grep -B 10 -A 20 "Execution failed for task" debug-build.log >> build-errors.txt 2>/dev/null || echo "No task execution failures found" >> build-errors.txt

            echo "" >> build-errors.txt
            echo "=== FAILED TASKS ===" >> build-errors.txt
            grep "> Task :.*FAILED" debug-build.log >> build-errors.txt 2>/dev/null || echo "No failed tasks found" >> build-errors.txt

            echo "" >> build-errors.txt
            echo "=== ERROR PATTERNS ===" >> build-errors.txt
            grep -i -E "error|exception|failed|cannot|unable" debug-build.log | grep -v "at org.gradle" | head -50 >> build-errors.txt 2>/dev/null || echo "No error patterns found" >> build-errors.txt

            echo "" >> build-errors.txt
            echo "=== COMPILATION ERRORS ===" >> build-errors.txt
            grep -i -E "error:|error code|compilation error|cannot find symbol|package.*does not exist|class.*not found" debug-build.log >> build-errors.txt 2>/dev/null || echo "No compilation errors found" >> build-errors.txt

            echo "" >> build-errors.txt
            echo "=== LAST 50 LINES (MOST RECENT ERRORS) ===" >> build-errors.txt
            tail -n 50 debug-build.log >> build-errors.txt

            # Display the error file prominently
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âŒâŒâŒ BUILD FAILED WITH EXIT CODE $BUILD_EXIT_CODE âŒâŒâŒ"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“„ EXTRACTED ERROR MESSAGES (also saved to build-errors.txt):"
            echo ""
            cat build-errors.txt
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "=== LAST 150 LINES OF BUILD LOG (MOST RECENT) ==="
            tail -n 150 debug-build.log
            echo ""
            echo "ğŸ“‹ Full log: debug-build.log ($(wc -l < debug-build.log) lines)"
            echo "ğŸ“‹ Errors: build-errors.txt"
            exit 1
          fi

          echo "âœ… Build succeeded!"

          # Verify debug APK was created (only if build succeeded)
          echo ""
          echo "=== Verifying debug APK was created ==="
          if [ -f "app/build/outputs/apk/debug/app-debug.apk" ]; then
            echo "âœ… Debug APK created successfully!"
            ls -lh app/build/outputs/apk/debug/
          else
            echo "âš ï¸ Debug APK not found at expected location"
            echo "Searching for APK files..."
            find . -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found anywhere"
            echo ""
            echo "Checking build outputs directory:"
            ls -la app/build/outputs/ 2>/dev/null || echo "app/build/outputs does not exist"
            ls -la app/build/ 2>/dev/null || echo "app/build does not exist"
          fi

      - name: Set version code and version name for Android
        script: |
          cd android/app
          echo "=== Setting Android Version ==="

          # Use Codemagic's BUILD_NUMBER if available (auto-increments per build)
          # Otherwise, read current version and increment it
          BUILD_GRADLE="build.gradle"

          if [ ! -f "$BUILD_GRADLE" ]; then
            echo "âŒ ERROR: build.gradle not found at android/app/build.gradle"
            exit 1
          fi

          # Extract current version code
          CURRENT_VERSION_CODE=$(grep "versionCode" "$BUILD_GRADLE" | head -1 | sed 's/.*versionCode //' | sed 's/[^0-9].*//')

          if [ -z "$CURRENT_VERSION_CODE" ]; then
            echo "âš ï¸ Could not extract current version code, defaulting to 1"
            CURRENT_VERSION_CODE=1
          fi

          echo "Current version code in build.gradle: $CURRENT_VERSION_CODE"

          # Determine new version code
          if [ ! -z "$BUILD_NUMBER" ]; then
            # Use Codemagic's BUILD_NUMBER if it's >= current (avoids skipping versions)
            if [ "$BUILD_NUMBER" -ge "$CURRENT_VERSION_CODE" ]; then
              NEW_VERSION_CODE="$BUILD_NUMBER"
              echo "Using Codemagic BUILD_NUMBER: $NEW_VERSION_CODE"
            else
              # BUILD_NUMBER is lower than current, increment current instead
              NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))
              echo "BUILD_NUMBER ($BUILD_NUMBER) is lower than current ($CURRENT_VERSION_CODE), incrementing to: $NEW_VERSION_CODE"
            fi
          else
            # Increment current version code
            NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))
            echo "No BUILD_NUMBER available, incrementing version code to: $NEW_VERSION_CODE"
          fi

          # Extract current version name
          CURRENT_VERSION_NAME=$(grep "versionName" "$BUILD_GRADLE" | head -1 | sed 's/.*versionName "//' | sed 's/".*//')

          if [ -z "$CURRENT_VERSION_NAME" ]; then
            echo "âš ï¸ Could not extract current version name, defaulting to 1.0.0"
            CURRENT_VERSION_NAME="1.0.0"
          fi

          echo "Current version name (raw): $CURRENT_VERSION_NAME"

          # Normalize version to exactly 3 parts (major.minor.patch)
          # Extract only the first 3 parts, ignoring any additional parts
          # This fixes malformed versions like "1.0.1.0.1.0" -> "1.0.1"
          MAJOR=$(echo "$CURRENT_VERSION_NAME" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION_NAME" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION_NAME" | cut -d. -f3)

          # Default to 0 if empty
          MAJOR=${MAJOR:-1}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Validate that all parts are numeric (Android/Google Play requirement)
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "âš ï¸ WARNING: Version contains non-numeric parts, normalizing to 1.0.0"
            MAJOR=1
            MINOR=0
            PATCH=0
          fi

          # Increment patch version
          PATCH=$((PATCH + 1))
          NEW_VERSION_NAME="$MAJOR.$MINOR.$PATCH"

          # Validate final version format (must be exactly 3 parts, all numeric)
          if ! [[ "$NEW_VERSION_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Invalid version format: $NEW_VERSION_NAME"
            echo "Version must be in format: major.minor.patch (e.g., 1.0.1)"
            exit 1
          fi

          echo "Normalized and incremented version name: $NEW_VERSION_NAME"

          # Update version code in build.gradle
          # Handle both formats: versionCode 2 and versionCode = 2
          sed -i '' "s/versionCode [0-9]*/versionCode $NEW_VERSION_CODE/g" "$BUILD_GRADLE" || \
          sed -i '' "s/versionCode = [0-9]*/versionCode = $NEW_VERSION_CODE/g" "$BUILD_GRADLE" || \
          sed -i '' "s/versionCode[[:space:]]*[0-9]*/versionCode $NEW_VERSION_CODE/g" "$BUILD_GRADLE" || {
            echo "âŒ ERROR: Failed to update versionCode in build.gradle"
            exit 1
          }

          # Update version name in build.gradle
          # Handle both formats: versionName "1.0.1" and versionName = "1.0.1"
          sed -i '' "s/versionName \"[^\"]*\"/versionName \"$NEW_VERSION_NAME\"/g" "$BUILD_GRADLE" || \
          sed -i '' "s/versionName = \"[^\"]*\"/versionName = \"$NEW_VERSION_NAME\"/g" "$BUILD_GRADLE" || {
            echo "âŒ ERROR: Failed to update versionName in build.gradle"
            exit 1
          }

          # Verify the update
          echo ""
          echo "=== Verification ==="
          UPDATED_VERSION_CODE=$(grep "versionCode" "$BUILD_GRADLE" | head -1 | sed 's/.*versionCode //' | sed 's/[^0-9].*//')
          UPDATED_VERSION_NAME=$(grep "versionName" "$BUILD_GRADLE" | head -1 | sed 's/.*versionName "//' | sed 's/".*//')

          echo "Updated version code: $UPDATED_VERSION_CODE"
          echo "Updated version name: $UPDATED_VERSION_NAME"

          if [ "$UPDATED_VERSION_CODE" != "$NEW_VERSION_CODE" ]; then
            echo "âŒ ERROR: Version code was not updated correctly"
            echo "Expected: $NEW_VERSION_CODE"
            echo "Found: $UPDATED_VERSION_CODE"
            exit 1
          fi

          if [ "$UPDATED_VERSION_NAME" != "$NEW_VERSION_NAME" ]; then
            echo "âŒ ERROR: Version name was not updated correctly"
            echo "Expected: $NEW_VERSION_NAME"
            echo "Found: $UPDATED_VERSION_NAME"
            exit 1
          fi

          # Final validation: Ensure version name has exactly 3 parts
          PART_COUNT=$(echo "$UPDATED_VERSION_NAME" | tr '.' '\n' | wc -l | tr -d ' ')
          if [ "$PART_COUNT" -ne 3 ]; then
            echo "âŒ ERROR: Version name has $PART_COUNT parts, but must have exactly 3 parts"
            echo "Current value: $UPDATED_VERSION_NAME"
            exit 1
          fi

          # Validate format is numeric
          if ! [[ "$UPDATED_VERSION_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Version name format is invalid: $UPDATED_VERSION_NAME"
            echo "Version must be exactly 3 numeric parts separated by periods (e.g., 1.0.1)"
            exit 1
          fi

          echo ""
          echo "âœ… Version updated and validated successfully"
          echo "   Version Code: $UPDATED_VERSION_CODE"
          echo "   Version Name: $UPDATED_VERSION_NAME (validated: 3 parts, all numeric)"

      - name: Verify signing configuration before build
        script: |
          cd android
          echo "=== Verifying Signing Configuration ==="
          echo ""

          # Check if keystore.properties exists
          if [ ! -f "keystore.properties" ]; then
            echo "âŒ ERROR: keystore.properties not found!"
            echo "The keystore setup step should have created this file."
            echo "Please check the 'Set up Android keystore' step output."
            exit 1
          fi

          echo "âœ… keystore.properties found"

          # Verify keystore file exists
          KEYSTORE_FILE=$(grep "^storeFile=" keystore.properties | cut -d'=' -f2)
          if [ -z "$KEYSTORE_FILE" ]; then
            echo "âŒ ERROR: storeFile not found in keystore.properties"
            exit 1
          fi

          if [ ! -f "$KEYSTORE_FILE" ]; then
            echo "âŒ ERROR: Keystore file not found: $KEYSTORE_FILE"
            echo "Expected location: android/$KEYSTORE_FILE"
            exit 1
          fi

          echo "âœ… Keystore file found: $KEYSTORE_FILE"

          # Verify all required properties are set (without showing values)
          if ! grep -q "^keyAlias=" keystore.properties; then
            echo "âŒ ERROR: keyAlias not found in keystore.properties"
            exit 1
          fi

          if ! grep -q "^storePassword=" keystore.properties; then
            echo "âŒ ERROR: storePassword not found in keystore.properties"
            exit 1
          fi

          if ! grep -q "^keyPassword=" keystore.properties; then
            echo "âŒ ERROR: keyPassword not found in keystore.properties"
            exit 1
          fi

          echo "âœ… All signing properties are configured"
          echo ""
          echo "Signing configuration summary:"
          echo "  Keystore file: $KEYSTORE_FILE"
          echo "  Key alias: $(grep "^keyAlias=" keystore.properties | cut -d'=' -f2)"
          echo "  Store password: ***"
          echo "  Key password: ***"
          echo ""
          echo "âœ… Signing configuration verified - AAB will be signed during build"

      - name: Build Android App Bundle
        script: |
          cd android
          # Ensure JAVA_HOME is set (environment variables don't persist between steps)
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || /usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
          fi
          if [ -z "$JAVA_HOME" ] || [ ! -f "$JAVA_HOME/bin/java" ]; then
            echo "âŒ ERROR: JAVA_HOME is not set or invalid!"
            echo "Attempting to find Java 17..."
            export JAVA_HOME=$(/usr/libexec/java_home -v 17)
          fi
          export JAVA_HOME
          echo "Building with JAVA_HOME: $JAVA_HOME"

          # Ensure gradle.properties has org.gradle.java.home set (it should from previous step, but verify)
          if [ -f gradle.properties ]; then
            if ! grep -q "^org\.gradle\.java\.home=" gradle.properties; then
              echo "Setting org.gradle.java.home in gradle.properties..."
              echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            fi
          else
            echo "Creating gradle.properties with org.gradle.java.home..."
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
          fi

          # Verify Java version
          echo "Java version:"
          "$JAVA_HOME/bin/java" -version

          # Clean build to ensure fresh state
          echo ""
          echo "=== Cleaning previous build ==="
          ./gradlew clean || true

          # Build with full error output
          echo ""
          echo "=== Building Android App Bundle (Release) ==="
          set -o pipefail
          ./gradlew bundleRelease --stacktrace --info 2>&1 | tee release-build.log
          BUNDLE_EXIT_CODE=${PIPESTATUS[0]}

          if [ $BUNDLE_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "âŒ Release build failed with exit code $BUNDLE_EXIT_CODE!"
            echo ""
            echo "=== FULL BUILD OUTPUT ==="
            cat release-build.log
            echo ""
            echo "=== Searching for specific errors ==="
            grep -i -A 10 -B 5 "error\|failed\|exception\|FAILURE" release-build.log | head -50 || echo "No obvious errors found"
            echo ""
            echo "âš ï¸ Release build failed. Trying to build debug bundle instead..."
            ./gradlew bundleDebug --stacktrace --info 2>&1 | tee debug-bundle.log
            DEBUG_BUNDLE_EXIT_CODE=${PIPESTATUS[0]}

            if [ $DEBUG_BUNDLE_EXIT_CODE -ne 0 ]; then
              echo ""
              echo "âŒ Debug bundle also failed!"
              echo "=== FULL DEBUG BUNDLE OUTPUT ==="
              cat debug-bundle.log
              exit 1
            else
              echo "âœ… Debug bundle built successfully!"
            fi
          else
            echo "âœ… Release bundle built successfully!"
          fi

          # Verify build artifacts were created (only if build succeeded)
          echo ""
          echo "=== Verifying build artifacts ==="
          echo "Checking for AAB files..."
          find app/build/outputs -name "*.aab" -type f 2>/dev/null | head -10 || echo "No AAB files found"
          echo ""
          echo "Checking for APK files..."
          find app/build/outputs -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"
          echo ""
          echo "Listing app/build/outputs directory structure:"
          ls -laR app/build/outputs/ 2>/dev/null | head -50 || echo "Outputs directory not found"
          echo ""
          echo "Full path to outputs:"
          pwd
          ls -la app/build/outputs/bundle/release/ 2>/dev/null || echo "Bundle release directory not found"
          ls -la app/build/outputs/bundle/debug/ 2>/dev/null || echo "Bundle debug directory not found"
          ls -la app/build/outputs/apk/release/ 2>/dev/null || echo "APK release directory not found"
          ls -la app/build/outputs/apk/debug/ 2>/dev/null || echo "APK debug directory not found"

          # Verify AAB is signed
          echo ""
          echo "=== Verifying AAB Signature ==="
          AAB_FILE=$(find app/build/outputs/bundle/release -name "*.aab" -type f 2>/dev/null | head -1)
          if [ ! -z "$AAB_FILE" ] && [ -f "$AAB_FILE" ]; then
            echo "Found AAB file: $AAB_FILE"
            echo "Verifying signature..."

            # Use jarsigner to verify the AAB is signed
            jarsigner -verify -verbose -certs "$AAB_FILE" 2>&1 | head -20 || echo "âš ï¸ jarsigner verification failed or not available"

            # Check if AAB contains signature files (META-INF/*.SF, META-INF/*.RSA)
            echo ""
            echo "Checking for signature files in AAB..."
            unzip -l "$AAB_FILE" 2>/dev/null | grep -E "META-INF/.*\.(SF|RSA|DSA|EC)" | head -10 || echo "âš ï¸ No signature files found in AAB"

            # If we can extract and check, verify signature files exist
            if unzip -l "$AAB_FILE" 2>/dev/null | grep -q "META-INF/.*\.SF"; then
              echo "âœ… AAB appears to be signed (contains signature files)"
            else
              echo "âŒ WARNING: AAB may not be signed (no signature files found)"
              echo "This could cause upload issues to Google Play Store"
            fi
          else
            echo "âš ï¸ Release AAB file not found for signature verification"
          fi

      - name: Build Release APK (for testing)
        script: |
          cd android
          # Ensure JAVA_HOME is set (environment variables don't persist between steps)
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(/usr/libexec/java_home -v 17 2>/dev/null || /usr/libexec/java_home -v 17+ 2>/dev/null || echo "")
          fi
          if [ -z "$JAVA_HOME" ] || [ ! -f "$JAVA_HOME/bin/java" ]; then
            echo "âŒ ERROR: JAVA_HOME is not set or invalid!"
            export JAVA_HOME=$(/usr/libexec/java_home -v 17)
          fi
          export JAVA_HOME
          echo "Building with JAVA_HOME: $JAVA_HOME"

          # Ensure gradle.properties has org.gradle.java.home set
          if [ -f gradle.properties ]; then
            if ! grep -q "^org\.gradle\.java\.home=" gradle.properties; then
              echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
            fi
          else
            echo "org.gradle.java.home=$JAVA_HOME" > gradle.properties
          fi

          # Build with full error output
          echo ""
          echo "=== Building Android Release APK ==="
          set -o pipefail
          ./gradlew assembleRelease --stacktrace --info 2>&1 | tee release-apk.log
          RELEASE_APK_EXIT_CODE=${PIPESTATUS[0]}

          if [ $RELEASE_APK_EXIT_CODE -ne 0 ]; then
            echo ""
            echo "âŒ Release APK build failed with exit code $RELEASE_APK_EXIT_CODE!"
            echo ""
            echo "=== FULL BUILD OUTPUT ==="
            cat release-apk.log
            echo ""
            echo "=== Searching for specific errors ==="
            grep -i -A 10 -B 5 "error\|failed\|exception\|FAILURE" release-apk.log | head -50 || echo "No obvious errors found"
            echo ""
            echo "âš ï¸ Release APK build failed. Debug APK should already be available from earlier step."
            # Don't exit - debug APK is already built
          else
            echo "âœ… Release APK built successfully!"
          fi

          # Verify build artifacts were created
          echo ""
          echo "=== Verifying build artifacts ==="
          echo "Checking for APK files..."
          find app/build/outputs -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"
          echo ""
          echo "Listing app/build/outputs directory structure:"
          ls -laR app/build/outputs/ 2>/dev/null | head -50 || echo "Outputs directory not found"
          echo ""
          echo "Full path to outputs:"
          pwd
          ls -la app/build/outputs/apk/release/ 2>/dev/null || echo "APK release directory not found"
          ls -la app/build/outputs/apk/debug/ 2>/dev/null || echo "APK debug directory not found"

      - name: Verify artifacts from workspace root
        script: |
          echo "=== Verifying artifacts from workspace root ==="
          echo "Current directory: $(pwd)"
          echo ""
          echo "Looking for AAB files:"
          find . -name "*.aab" -type f 2>/dev/null | head -10 || echo "No AAB files found"
          echo ""
          echo "Looking for APK files:"
          find . -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"
          echo ""
          echo "Checking android/app/build/outputs:"
          if [ -d "android/app/build/outputs" ]; then
            echo "âœ… Outputs directory exists"
            ls -laR android/app/build/outputs/ | head -100
          else
            echo "âŒ Outputs directory does not exist!"
            echo "Listing android/app/build directory:"
            ls -la android/app/build/ 2>/dev/null || echo "android/app/build does not exist"
          fi

      - name: Artifact Summary and Download Instructions
        script: |
          echo "=========================================="
          echo "ğŸ“¦ ARTIFACT SUMMARY"
          echo "=========================================="
          echo ""
          echo "Finding all APK and AAB files:"
          find . -type f \( -name "*.apk" -o -name "*.aab" \) 2>/dev/null | while read file; do
            echo "  âœ… Found: $file ($(du -h "$file" | cut -f1))"
          done || echo "  âš ï¸ No APK/AAB files found"
          echo ""
          echo "=========================================="
          echo "ğŸ“¥ HOW TO DOWNLOAD ARTIFACTS"
          echo "=========================================="
          echo ""
          echo "After a successful build, download your app files from Codemagic:"
          echo ""
          echo "1. Go to your Codemagic dashboard"
          echo "2. Click on the completed build"
          echo "3. Scroll to the 'Artifacts' section"
          echo "4. Click the download button next to:"
          echo "   - *.apk files (for direct installation)"
          echo "   - *.aab files (for Google Play Store upload)"
          echo ""
          echo "Or use the Codemagic CLI:"
          echo "  codemagic-cli builds artifacts <build-id>"
          echo ""
          echo "Artifacts are automatically collected from:"
          echo "  - android/app/build/outputs/**/*.apk"
          echo "  - android/app/build/outputs/**/*.aab"
          echo ""

    artifacts:
      - android/app/build/outputs/**/*.aab
      - android/app/build/outputs/**/*.apk
      - android/app/build/outputs/bundle/**/*
      - android/app/build/outputs/apk/**/*
      - android/app/build/outputs/**/debug/**
      - android/app/build/outputs/**/release/**
      - android/build-errors.txt
      - android/debug-build.log
      - android/release-build.log
      - android/debug-bundle.log
      - android/release-apk.log

    publishing:
      email:
        recipients:
          - justin@fluidinvestmentgroup.com
        notify:
          success: true
          failure: true

  ios-build:
    name: iOS Build
    max_build_duration: 120
    instance_type: mac_mini_m2
    # App Store Connect Integration
    # References the App Store Connect API key stored in Codemagic Team Settings
    # Integration name: "codemagic" (must match the key name in Codemagic Team Settings)
    # To change: Update the integration name here and ensure it exists in Codemagic Team Settings â†’ Integrations â†’ App Store Connect
    integrations:
      app_store_connect: codemagic
    environment:
      groups:
        - ios_certificates
        - app_store_connect
      node: 20
      vars:
        BUNDLE_ID: "com.kidscallhome.app"
        APP_NAME: "Kids Call Home"
        XCODE_WORKSPACE: "App.xcworkspace"  # Capacitor iOS uses workspace
        XCODE_SCHEME: "App"  # Default Capacitor scheme
        APP_STORE_APPLE_ID: "6756827237"  # From App Store Connect (confirmed in IOS_READINESS_STATUS.md)
      xcode: latest
      cocoapods: default
      ios_signing:
        # IMPORTANT: If you get "No matching profiles found" error:
        # 1. Go to Codemagic â†’ Teams â†’ Code Signing â†’ ios_certificates group
        # 2. Ensure you have:
        #    - A Distribution Certificate (not Development)
        #    - An App Store Provisioning Profile (not Development/Ad Hoc)
        #    - The provisioning profile must be for bundle ID: com.kidscallhome.app
        # 3. If profiles are missing, generate them in Codemagic or upload from Apple Developer
        # 4. Verify the bundle ID in the profile matches exactly: com.kidscallhome.app
        distribution_type: app_store  # or 'development' for testing
        bundle_identifier: "com.kidscallhome.app"
    scripts:
      - name: Install dependencies
        script: |
          npm ci

      - name: Build web app
        script: |
          npm run build

      - name: Generate iOS platform
        script: |
          echo "=== Generating iOS Platform ==="
          echo "Current directory: $(pwd)"
          echo ""

          # Check if ios/App/Podfile exists (indicates full iOS project)
          if [ -f "ios/App/Podfile" ]; then
            echo "âœ… iOS project already exists with Podfile"
          else
            echo "ğŸ“± iOS project not complete, generating it now..."

            # Remove partial ios directory if it exists (just templates)
            if [ -d "ios" ]; then
              echo "Removing partial ios directory..."
              # Save any template files we might need
              if [ -f "ios/Info.plist.template" ]; then
                cp ios/Info.plist.template /tmp/Info.plist.template.backup
              fi
              rm -rf ios
            fi

            # Add iOS platform fresh
            echo "Running: npx cap add ios"
            npx cap add ios

            if [ $? -ne 0 ]; then
              echo "âŒ Failed to add iOS platform!"
              exit 1
            fi

            echo "âœ… iOS project generated"
          fi

          # List the ios directory structure
          echo ""
          echo "iOS directory structure:"
          ls -la ios/ 2>/dev/null || echo "ios/ directory not found"
          echo ""
          if [ -d "ios/App" ]; then
            echo "ios/App directory:"
            ls -la ios/App/ 2>/dev/null || echo "ios/App is empty"
          fi

      - name: Sync Capacitor iOS
        script: |
          echo "=== Syncing Capacitor iOS Project ==="
          echo "Current directory: $(pwd)"
          echo ""

          # Sync web assets and native plugins
          echo "Running: npx cap sync ios"
          npx cap sync ios

          if [ $? -ne 0 ]; then
            echo "âŒ Capacitor sync failed!"
            echo ""
            echo "Attempting recovery..."

            # Try to add iOS platform if sync failed
            if [ ! -f "ios/App/Podfile" ]; then
              echo "Podfile missing, trying to regenerate iOS project..."
              rm -rf ios
              npx cap add ios
              npx cap sync ios
            fi
          fi

          # Verify key files exist
          echo ""
          echo "=== Verifying iOS Project Structure ==="

          if [ ! -d "ios/App" ]; then
            echo "âŒ ios/App directory not found!"
            exit 1
          fi
          echo "âœ… ios/App directory exists"
          ls -la ios/App/ | head -20

          # Check for Podfile (critical)
          if [ ! -f "ios/App/Podfile" ]; then
            echo "âŒ Podfile not found at ios/App/Podfile!"
            echo ""
            echo "This is a critical error. The iOS project was not generated correctly."
            echo "Searching for any Podfile..."
            find ios -name "Podfile" -type f 2>/dev/null || echo "No Podfile found anywhere"
            exit 1
          fi
          echo "âœ… Podfile found at ios/App/Podfile"

          # Check for Xcode project
          if [ -d "ios/App/App.xcodeproj" ]; then
            echo "âœ… Xcode project found"
          else
            echo "âš ï¸ Xcode project not found"
            find ios -name "*.xcodeproj" -type d 2>/dev/null || echo "No xcodeproj found"
          fi

          echo ""
          echo "âœ… Capacitor iOS sync completed"

      - name: Configure iOS permissions in Info.plist
        script: |
          # Ensure Info.plist exists and has required permissions
          INFO_PLIST="ios/App/App/Info.plist"

          if [ ! -f "$INFO_PLIST" ]; then
            echo "âš ï¸ Info.plist not found at $INFO_PLIST"
            echo "Searching for Info.plist..."
            find ios -name "Info.plist" -type f 2>/dev/null | head -5 || echo "No Info.plist found"
            echo "Will try to configure after CocoaPods install"
          else
            echo "ğŸ“ Configuring iOS permissions in $INFO_PLIST..."

            # Use PlistBuddy to add/update permissions (macOS tool)
            /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true

            /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSMicrophoneUsageDescription 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true

            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || true

            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || true

            /usr/libexec/PlistBuddy -c "Add :NSUserNotificationsUsageDescription string 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSUserNotificationsUsageDescription 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || true

            echo "âœ… iOS permissions configured"
          fi

      - name: Install CocoaPods dependencies
        script: |
          echo "=== Installing CocoaPods Dependencies ==="
          echo "Current directory: $(pwd)"
          echo ""

          # Check if iOS directory exists
          if [ ! -d "ios" ]; then
            echo "âŒ iOS directory not found!"
            echo "This should have been created by 'Sync Capacitor iOS' step"
            exit 1
          fi

          # Find the Podfile location
          PODFILE_PATH=$(find ios -name "Podfile" -type f | head -1)

          if [ -z "$PODFILE_PATH" ]; then
            echo "âš ï¸ Podfile not found. Checking iOS directory structure..."
            echo ""
            echo "iOS directory contents:"
            ls -la ios/ 2>/dev/null || echo "ios/ directory is empty or doesn't exist"
            echo ""

            # Check if ios/App exists
            if [ -d "ios/App" ]; then
              echo "ios/App directory exists. Contents:"
              ls -la ios/App/ 2>/dev/null || echo "ios/App is empty"
              echo ""

              # Try to create Podfile if it's missing (Capacitor should have created it)
              echo "âš ï¸ Podfile missing. This might indicate Capacitor sync didn't complete properly."
              echo "Attempting to sync again..."
              npx cap sync ios

              # Check again
              PODFILE_PATH=$(find ios -name "Podfile" -type f | head -1)
              if [ -z "$PODFILE_PATH" ]; then
                echo "âŒ Podfile still not found after sync!"
                exit 1
              fi
            else
              echo "âŒ ios/App directory not found!"
              echo "Capacitor iOS project was not created properly."
              exit 1
            fi
          fi

          # Get the directory containing the Podfile
          PODFILE_DIR=$(dirname "$PODFILE_PATH")
          echo "âœ… Found Podfile at: $PODFILE_PATH"
          echo "Changing to directory: $PODFILE_DIR"
          cd "$PODFILE_DIR"

          # Verify CocoaPods is installed
          echo ""
          echo "=== Verifying CocoaPods ==="
          if ! command -v pod &> /dev/null; then
            echo "âŒ CocoaPods not found in PATH!"
            echo "Codemagic should have CocoaPods installed. Checking version..."
            which pod || echo "pod command not found"
            exit 1
          fi

          POD_VERSION=$(pod --version 2>/dev/null || echo "unknown")
          echo "âœ… CocoaPods version: $POD_VERSION"

          echo ""
          echo "=== Running pod install ==="
          pod install

          if [ $? -ne 0 ]; then
            echo "âŒ pod install failed!"
            echo ""
            echo "Troubleshooting:"
            echo "1. Check if CocoaPods is installed: pod --version"
            echo "2. Try updating CocoaPods: pod repo update"
            echo "3. Check Podfile syntax"
            exit 1
          fi

          echo "âœ… CocoaPods dependencies installed successfully"

      - name: Configure iOS permissions after CocoaPods (if needed)
        script: |
          # Try again after CocoaPods install in case Info.plist was generated
          INFO_PLIST="ios/App/App/Info.plist"
          if [ -f "$INFO_PLIST" ]; then
            echo "ğŸ“ Configuring iOS permissions (post-CocoaPods)..."
            /usr/libexec/PlistBuddy -c "Add :NSCameraUsageDescription string 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSCameraUsageDescription 'Kids Call Home needs camera access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSMicrophoneUsageDescription 'Kids Call Home needs microphone access for video calls with family.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryUsageDescription string 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryUsageDescription 'Kids Call Home needs photo library access to share photos with family.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSPhotoLibraryAddUsageDescription string 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSPhotoLibraryAddUsageDescription 'Kids Call Home needs permission to save photos from messages.'" "$INFO_PLIST" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :NSUserNotificationsUsageDescription string 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Set :NSUserNotificationsUsageDescription 'Kids Call Home needs notification permission to alert you about calls and messages.'" "$INFO_PLIST" 2>/dev/null || true
            echo "âœ… iOS permissions configured"
          fi

      - name: Verify and set bundle identifier in Xcode project
        script: |
          cd ios/App
          echo "=== Verifying Bundle Identifier ==="
          echo "Expected bundle ID: $BUNDLE_ID"
          echo ""

          # Find the project.pbxproj file
          PROJECT_FILE=$(find . -name "*.xcodeproj" -type d | head -1)
          if [ -z "$PROJECT_FILE" ]; then
            echo "âŒ Xcode project not found!"
            echo "Searching for Xcode projects..."
            find . -name "*.xcodeproj" -type d 2>/dev/null || echo "No .xcodeproj found"
            exit 1
          fi

          PBXPROJ="$PROJECT_FILE/project.pbxproj"
          echo "Found project: $PROJECT_FILE"
          echo "Reading: $PBXPROJ"
          echo ""

          # Debug: Show all PRODUCT_BUNDLE_IDENTIFIER lines (Capacitor may use different formats)
          echo "=== All PRODUCT_BUNDLE_IDENTIFIER lines in project ==="
          grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -20 || echo "No PRODUCT_BUNDLE_IDENTIFIER found"
          echo ""

          # Capacitor projects may use format: PRODUCT_BUNDLE_IDENTIFIER = com.example.app; (no quotes)
          # or: PRODUCT_BUNDLE_IDENTIFIER = "com.example.app"; (with quotes)
          # Extract bundle ID handling both formats
          CURRENT_BUNDLE_ID=$(grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -1 | sed 's/.*PRODUCT_BUNDLE_IDENTIFIER = //' | sed 's/[";]//g' | tr -d '[:space:]')
          echo "Current bundle ID in project: '$CURRENT_BUNDLE_ID'"

          # Update bundle identifier if it doesn't match or is empty
          if [ "$CURRENT_BUNDLE_ID" != "$BUNDLE_ID" ]; then
            echo "âš ï¸ Bundle ID mismatch! Updating all instances to $BUNDLE_ID..."

            # Update both quoted and unquoted formats
            # Format 1: PRODUCT_BUNDLE_IDENTIFIER = "something";
            sed -i '' "s/PRODUCT_BUNDLE_IDENTIFIER = \"[^\"]*\"/PRODUCT_BUNDLE_IDENTIFIER = \"$BUNDLE_ID\"/g" "$PBXPROJ"
            # Format 2: PRODUCT_BUNDLE_IDENTIFIER = something; (no quotes, Capacitor default)
            sed -i '' "s/PRODUCT_BUNDLE_IDENTIFIER = [^;\"]*;/PRODUCT_BUNDLE_IDENTIFIER = $BUNDLE_ID;/g" "$PBXPROJ"

            echo "âœ… Bundle ID updated in project.pbxproj"

            # Verify the update worked
            echo ""
            echo "After update - PRODUCT_BUNDLE_IDENTIFIER lines:"
            grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -10 || echo "No lines found"
          else
            echo "âœ… Bundle ID matches"
          fi

          # Info.plist typically uses $(PRODUCT_BUNDLE_IDENTIFIER) variable, which is fine
          if [ -f "App/Info.plist" ]; then
            echo ""
            echo "Checking Info.plist..."
            INFO_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "App/Info.plist" 2>/dev/null || echo "")
            echo "Info.plist CFBundleIdentifier: $INFO_BUNDLE_ID"

            # If it uses $(PRODUCT_BUNDLE_IDENTIFIER), that's correct - it will inherit from project
            if [ "$INFO_BUNDLE_ID" = '$(PRODUCT_BUNDLE_IDENTIFIER)' ]; then
              echo "âœ… Info.plist uses project variable (correct)"
            elif [ "$INFO_BUNDLE_ID" != "$BUNDLE_ID" ] && [ ! -z "$INFO_BUNDLE_ID" ]; then
              echo "âš ï¸ Updating Info.plist bundle ID to use project variable..."
              /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier \$(PRODUCT_BUNDLE_IDENTIFIER)" "App/Info.plist" 2>/dev/null || true
              echo "âœ… Info.plist updated to use \$(PRODUCT_BUNDLE_IDENTIFIER)"
            fi
          fi

          echo ""
          echo "=== Final Bundle ID Verification ==="
          FINAL_BUNDLE_ID=$(grep "PRODUCT_BUNDLE_IDENTIFIER" "$PBXPROJ" | head -1 | sed 's/.*PRODUCT_BUNDLE_IDENTIFIER = //' | sed 's/[";]//g' | tr -d '[:space:]')
          echo "Final bundle ID: '$FINAL_BUNDLE_ID'"

          if [ "$FINAL_BUNDLE_ID" != "$BUNDLE_ID" ]; then
            echo "âš ï¸ WARNING: Bundle ID may not have been updated correctly"
            echo "Expected: $BUNDLE_ID"
            echo "Found: $FINAL_BUNDLE_ID"
            echo ""
            echo "Attempting to add bundle ID if missing..."
            # If no bundle ID exists, we may need to add it - but this is unusual
            # For now, continue and let Xcode/signing handle it
            echo "Continuing with build - signing step will set the correct bundle ID"
          else
            echo "âœ… Bundle ID verification passed"
          fi

      - name: List available provisioning profiles
        script: |
          echo "=== Available Provisioning Profiles ==="
          echo "Checking for profiles matching bundle ID: $BUNDLE_ID"
          echo ""

          # List all provisioning profiles
          if [ -d ~/Library/MobileDevice/Provisioning\ Profiles ]; then
            echo "Provisioning profiles directory exists"
            ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ | head -20 || echo "No profiles found"
            echo ""

            # Try to extract bundle IDs from profiles
            echo "Extracting bundle IDs from profiles..."
            for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
              if [ -f "$profile" ]; then
                BUNDLE_ID_IN_PROFILE=$(security cms -D -i "$profile" 2>/dev/null | grep -A 1 "application-identifier" | grep -o '"[^"]*"' | head -1 | sed 's/"//g' | sed 's/.*\.//' || echo "")
                if [ ! -z "$BUNDLE_ID_IN_PROFILE" ]; then
                  echo "  Profile: $(basename "$profile")"
                  echo "    Bundle ID: $BUNDLE_ID_IN_PROFILE"
                fi
              fi
            done
          else
            echo "âš ï¸ Provisioning profiles directory not found"
          fi

          echo ""
          echo "=== Codemagic Environment Check ==="
          echo "BUNDLE_ID: $BUNDLE_ID"
          echo "Distribution type: app_store"
          echo ""
          echo "âš ï¸ If no matching profiles are found above, you need to:"
          echo "1. Go to Codemagic â†’ Teams â†’ Code Signing"
          echo "2. Ensure the 'ios_certificates' group contains:"
          echo "   - A Distribution Certificate"
          echo "   - An App Store Provisioning Profile for bundle ID: $BUNDLE_ID"
          echo "3. The provisioning profile must match exactly: $BUNDLE_ID"

      - name: Set up provisioning profiles settings on Xcode project
        script: |
          echo "=== Setting up provisioning profiles ==="
          echo "Bundle ID: $BUNDLE_ID"
          echo "Distribution type: app_store"
          echo ""

          # Use Codemagic's xcode-project command to set up profiles
          xcode-project use-profiles || {
            echo "âŒ Failed to set up provisioning profiles"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify 'ios_certificates' group exists in Codemagic"
            echo "2. Ensure it contains an App Store provisioning profile for: $BUNDLE_ID"
            echo "3. Check that the certificate and profile are valid and not expired"
            echo "4. Try regenerating the certificate/profile in Codemagic if needed"
            exit 1
          }

          echo "âœ… Provisioning profiles configured"

      - name: Set version and build number for App Store distribution
        script: |
          cd ios/App
          echo "=== Setting iOS Version and Build Number ==="

          INFO_PLIST="App/Info.plist"

          # Read current version name (CFBundleShortVersionString)
          if [ -f "$INFO_PLIST" ]; then
            CURRENT_VERSION_NAME=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$INFO_PLIST" 2>/dev/null || echo "")
          else
            CURRENT_VERSION_NAME=""
          fi

          # If version name not found, try reading from project.pbxproj
          if [ -z "$CURRENT_VERSION_NAME" ]; then
            PROJECT_FILE=$(find . -name "*.xcodeproj" -type d | head -1)
            if [ ! -z "$PROJECT_FILE" ]; then
              PBXPROJ="$PROJECT_FILE/project.pbxproj"
              CURRENT_VERSION_NAME=$(grep "MARKETING_VERSION" "$PBXPROJ" | head -1 | sed 's/.*MARKETING_VERSION = //' | sed 's/;//' | sed 's/"//g' | tr -d '[:space:]' || echo "")
            fi
          fi

          # Default to 1.0.0 if not found
          if [ -z "$CURRENT_VERSION_NAME" ]; then
            CURRENT_VERSION_NAME="1.0.0"
            echo "âš ï¸ Version name not found, defaulting to: $CURRENT_VERSION_NAME"
          else
            echo "Current version name (raw): $CURRENT_VERSION_NAME"
          fi

          # Normalize version to exactly 3 parts (major.minor.patch)
          # Extract only the first 3 parts, ignoring any additional parts
          # This fixes malformed versions like "1.0.1.0.1.0" -> "1.0.1"
          MAJOR=$(echo "$CURRENT_VERSION_NAME" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION_NAME" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION_NAME" | cut -d. -f3)

          # Default to 0 if empty or non-numeric
          MAJOR=${MAJOR:-1}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Validate that all parts are numeric (Apple requirement)
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "âš ï¸ WARNING: Version contains non-numeric parts, normalizing to 1.0.0"
            MAJOR=1
            MINOR=0
            PATCH=0
          fi

          # Increment patch version
          PATCH=$((PATCH + 1))
          NEW_VERSION_NAME="$MAJOR.$MINOR.$PATCH"

          # Validate final version format (must be exactly 3 parts, all numeric)
          if ! [[ "$NEW_VERSION_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Invalid version format: $NEW_VERSION_NAME"
            echo "Version must be in format: major.minor.patch (e.g., 1.0.1)"
            exit 1
          fi

          echo "Normalized and incremented version name: $NEW_VERSION_NAME"

          # Determine build number (CFBundleVersion)
          # Use Codemagic's BUILD_NUMBER if available (auto-increments per build)
          # Otherwise fall back to timestamp-based build number
          if [ ! -z "$BUILD_NUMBER" ]; then
            BUILD_VERSION="$BUILD_NUMBER"
            echo "Using Codemagic BUILD_NUMBER: $BUILD_VERSION"
          else
            # Fallback: Use timestamp as build number (ensures uniqueness)
            BUILD_VERSION=$(date +%s)
            echo "Using timestamp-based build number: $BUILD_VERSION"
          fi

          # Update CFBundleShortVersionString (version name) in Info.plist
          # Use quotes around the value to ensure proper string handling
          if [ -f "$INFO_PLIST" ]; then
            /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString \"$NEW_VERSION_NAME\"" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string \"$NEW_VERSION_NAME\"" "$INFO_PLIST" 2>/dev/null || {
              echo "âŒ ERROR: Failed to update CFBundleShortVersionString in Info.plist"
              exit 1
            }
            echo "âœ… Updated CFBundleShortVersionString to $NEW_VERSION_NAME in Info.plist"

            # Verify the update
            VERIFIED_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$INFO_PLIST" 2>/dev/null || echo "")
            if [ "$VERIFIED_VERSION" != "$NEW_VERSION_NAME" ]; then
              echo "âŒ ERROR: Version verification failed!"
              echo "Expected: $NEW_VERSION_NAME"
              echo "Found: $VERIFIED_VERSION"
              exit 1
            fi

            # Update CFBundleVersion (build number) in Info.plist
            /usr/libexec/PlistBuddy -c "Set :CFBundleVersion \"$BUILD_VERSION\"" "$INFO_PLIST" 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string \"$BUILD_VERSION\"" "$INFO_PLIST" 2>/dev/null || {
              echo "âŒ ERROR: Failed to update CFBundleVersion in Info.plist"
              exit 1
            }
            echo "âœ… Updated CFBundleVersion to $BUILD_VERSION in Info.plist"
          fi

          # Also update in Xcode project file (project.pbxproj)
          PROJECT_FILE=$(find . -name "*.xcodeproj" -type d | head -1)
          if [ ! -z "$PROJECT_FILE" ]; then
            PBXPROJ="$PROJECT_FILE/project.pbxproj"

            # Update MARKETING_VERSION (version name) in project.pbxproj
            # Handle both formats: MARKETING_VERSION = "1.0.1"; and MARKETING_VERSION = 1.0.1;
            sed -i '' "s/MARKETING_VERSION = \"[^\"]*\"/MARKETING_VERSION = \"$NEW_VERSION_NAME\"/g" "$PBXPROJ" 2>/dev/null || \
            sed -i '' "s/MARKETING_VERSION = [^;]*/MARKETING_VERSION = $NEW_VERSION_NAME/g" "$PBXPROJ" 2>/dev/null || {
              echo "âš ï¸ WARNING: Failed to update MARKETING_VERSION in project.pbxproj"
            }
            echo "âœ… Updated MARKETING_VERSION to $NEW_VERSION_NAME in project.pbxproj"

            # Verify MARKETING_VERSION update
            VERIFIED_MARKETING_VERSION=$(grep "MARKETING_VERSION" "$PBXPROJ" | head -1 | sed 's/.*MARKETING_VERSION = //' | sed 's/;//' | sed 's/"//g' | tr -d '[:space:]' || echo "")
            if [[ ! "$VERIFIED_MARKETING_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "âš ï¸ WARNING: MARKETING_VERSION verification failed or invalid format"
              echo "Found: $VERIFIED_MARKETING_VERSION"
            fi

            # Update CURRENT_PROJECT_VERSION (build number) in project.pbxproj
            sed -i '' "s/CURRENT_PROJECT_VERSION = [^;]*/CURRENT_PROJECT_VERSION = $BUILD_VERSION/g" "$PBXPROJ" 2>/dev/null || {
              echo "âš ï¸ WARNING: Failed to update CURRENT_PROJECT_VERSION in project.pbxproj"
            }
            echo "âœ… Updated CURRENT_PROJECT_VERSION to $BUILD_VERSION in project.pbxproj"
          fi

          echo ""
          echo "=== Final iOS Version Summary ==="
          echo "Version Name (CFBundleShortVersionString): $NEW_VERSION_NAME"
          echo "Build Number (CFBundleVersion): $BUILD_VERSION"
          echo ""
          echo "=== Final Verification ==="
          if [ -f "$INFO_PLIST" ]; then
            FINAL_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$INFO_PLIST" 2>/dev/null || echo "")
            FINAL_BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$INFO_PLIST" 2>/dev/null || echo "")
            echo "Info.plist CFBundleShortVersionString: $FINAL_VERSION"
            echo "Info.plist CFBundleVersion: $FINAL_BUILD"

            # Validate final version format
            if [[ ! "$FINAL_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "âŒ ERROR: Final version format is invalid: $FINAL_VERSION"
              echo "Version must be exactly 3 numeric parts separated by periods (e.g., 1.0.1)"
              exit 1
            fi

            # Count the number of parts
            PART_COUNT=$(echo "$FINAL_VERSION" | tr '.' '\n' | wc -l | tr -d ' ')
            if [ "$PART_COUNT" -ne 3 ]; then
              echo "âŒ ERROR: Version has $PART_COUNT parts, but must have exactly 3 parts"
              echo "Current value: $FINAL_VERSION"
              exit 1
            fi

            echo "âœ… Version format validation passed (3 parts, all numeric)"
          fi
          echo "âœ… iOS version updated successfully"

      - name: Build IPA for distribution
        script: |
          echo "=== Building IPA for Distribution ==="
          echo "Workspace: ios/App/$XCODE_WORKSPACE"
          echo "Scheme: $XCODE_SCHEME"
          echo ""

          # Build IPA
          xcode-project build-ipa \
            --workspace "ios/App/$XCODE_WORKSPACE" \
            --scheme "$XCODE_SCHEME"

          # Verify IPA was created
          echo ""
          echo "=== Verifying IPA was created ==="
          IPA_PATH=$(find build/ios/ipa -name "*.ipa" -type f 2>/dev/null | head -1)

          if [ -z "$IPA_PATH" ]; then
            echo "âš ï¸ IPA not found in build/ios/ipa/, searching other locations..."
            find . -name "*.ipa" -type f 2>/dev/null | head -10 || echo "No IPA files found"
            echo ""
            echo "Common IPA locations:"
            ls -la build/ios/ipa/ 2>/dev/null || echo "build/ios/ipa/ does not exist"
            ls -la build/ 2>/dev/null || echo "build/ does not exist"
          else
            echo "âœ… IPA found: $IPA_PATH"
            ls -lh "$IPA_PATH"
            echo ""
            echo "IPA size: $(du -h "$IPA_PATH" | cut -f1)"
          fi

      - name: Verify App Store Connect configuration before publishing
        script: |
          echo "=== Verifying App Store Connect Configuration ==="
          echo ""

          # Check if IPA exists
          IPA_PATH=$(find build/ios/ipa -name "*.ipa" -type f 2>/dev/null | head -1)
          if [ -z "$IPA_PATH" ]; then
            echo "âŒ ERROR: IPA file not found!"
            echo "Cannot publish to App Store Connect without an IPA file."
            echo "Expected location: build/ios/ipa/*.ipa"
            echo ""
            echo "Searching for IPA files..."
            find . -name "*.ipa" -type f 2>/dev/null || echo "No IPA files found anywhere"
            exit 1
          fi

          echo "âœ… IPA file found: $IPA_PATH"
          echo ""

          # Check App Store Connect variables
          echo "=== App Store Connect Configuration Check ==="
          echo "APP_STORE_APPLE_ID: ${APP_STORE_APPLE_ID:-âŒ NOT SET}"
          echo "BUNDLE_ID: ${BUNDLE_ID:-âŒ NOT SET}"
          echo ""

          # Check if integration exists (we can't directly verify, but we can document)
          echo "=== Integration Check ==="
          echo "Expected integration name: 'codemagic'"
          echo "This integration must be configured in:"
          echo "  Codemagic â†’ Teams â†’ Integrations â†’ App Store Connect"
          echo ""
          echo "The integration should contain:"
          echo "  - APP_STORE_CONNECT_API_KEY_ID"
          echo "  - APP_STORE_CONNECT_ISSUER_ID"
          echo "  - APP_STORE_CONNECT_API_KEY (P8 file content)"
          echo ""

          if [ -z "$APP_STORE_APPLE_ID" ]; then
            echo "âš ï¸ WARNING: APP_STORE_APPLE_ID is not set!"
            echo "This is required for App Store Connect publishing."
            echo "Set it in the workflow vars section or as an environment variable."
          fi

          echo ""
          echo "âœ… Pre-publishing checks complete"

    artifacts:
      - build/ios/ipa/*.ipa
      - /tmp/xcodebuild_logs/*.log
      - $HOME/Library/Developer/Xcode/DerivedData/**/Build/**/*.app
      - $HOME/Library/Developer/Xcode/DerivedData/**/Build/**/*.dSYM

    publishing:
      email:
        recipients:
          - justin@fluidinvestmentgroup.com
        notify:
          success: true
          failure: true
      # App Store Connect / TestFlight Publishing Configuration
      #
      # CONFIGURATION NOTES:
      # - auth: integration - Uses the App Store Connect API key stored in Codemagic
      #   - Integration name: "codemagic" (must match the key name in Codemagic Team Settings)
      #   - To change: Update the integration name in Codemagic Team Settings â†’ Integrations â†’ App Store Connect
      #   - Required environment variables (set in Codemagic Team Settings):
      #     * APP_STORE_CONNECT_API_KEY_ID - Your App Store Connect API Key ID
      #     * APP_STORE_CONNECT_ISSUER_ID - Your App Store Connect Issuer ID
      #     * APP_STORE_CONNECT_API_KEY - Your App Store Connect API private key (P8 file content)
      #
      # - submit_to_testflight: true - Automatically uploads successful builds to TestFlight
      #   - Set to false to disable TestFlight uploads (builds will still be available as artifacts)
      #
      # - beta_groups: List of TestFlight beta group names to automatically distribute to
      #   - Builds will be automatically distributed to these groups after TestFlight upload
      #   - Common groups: "Internal Testers", "External Testers", "QA Team"
      #   - Groups must exist in App Store Connect â†’ TestFlight â†’ Groups
      #   - To disable auto-distribution: Comment out or remove the beta_groups section
      #
      # - submit_to_app_store: true - Automatically submits builds to App Store for review
      #   - Set to false for TestFlight-only distribution (no App Store submission)
      #   - When true: Builds are uploaded to TestFlight AND submitted to App Store review
      #
      # BUNDLE ID & TEAM CONFIGURATION:
      # - Bundle ID: Set in vars.BUNDLE_ID (currently: com.kidscallhome.app)
      #   - To change: Update line 518 in this file (search for "BUNDLE_ID:")
      # - Team: Configured via ios_signing section (around line 530-540)
      #   - Distribution type: app_store (required for TestFlight/App Store)
      #   - Bundle identifier: Must match vars.BUNDLE_ID
      #
      # APPLE ID:
      # - APP_STORE_APPLE_ID: Set in vars.APP_STORE_APPLE_ID (currently: 6756827237)
      #   - To change: Update line 522 in this file (search for "APP_STORE_APPLE_ID:")
      #   - Find your Apple ID in App Store Connect â†’ My Apps â†’ [Your App] â†’ App Information
      #
      app_store_connect:
        auth: integration
        # Integration name: "codemagic" (configured in Codemagic Team Settings)
        # To use a different integration, change the name here and ensure it exists in Codemagic
        #
        # IMPORTANT: If publishing fails, verify:
        # 1. The integration "codemagic" exists in Codemagic â†’ Teams â†’ Integrations â†’ App Store Connect
        # 2. The integration contains valid App Store Connect API credentials:
        #    - APP_STORE_CONNECT_API_KEY_ID
        #    - APP_STORE_CONNECT_ISSUER_ID
        #    - APP_STORE_CONNECT_API_KEY (P8 file content)
        # 3. The API key has the correct permissions (App Manager or Admin role)
        # 4. The APP_STORE_APPLE_ID matches your app in App Store Connect
        #
        submit_to_testflight: true
        # Automatic TestFlight distribution to beta groups
        # Uncomment and customize the group names to match your TestFlight groups in App Store Connect
        # Groups must be created in App Store Connect â†’ TestFlight â†’ Groups before they can be used here
        # If the group doesn't exist, publishing will fail - either create the group or comment out beta_groups
        beta_groups:
          - "Internal Testers"  # Change to your actual TestFlight group name(s)
        # Automatic App Store submission
        # When true: Builds are uploaded to TestFlight AND submitted to App Store for review
        # When false: Builds are uploaded to TestFlight only (no App Store submission)
        submit_to_app_store: true
